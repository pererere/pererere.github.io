<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FoodLink: Dispatcher</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">FoodLink
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md__d_1_2_g_i_t_2_food_link_2foodlink_8client_2node__modules_2undici_2docs_2api_2_dispatcher.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Dispatcher</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md21317"></a></p>
<p>Extends: <code>events.EventEmitter</code></p>
<p>Dispatcher is the core API used to dispatch requests.</p>
<p>Requests are not guaranteed to be dispatched in order of invocation.</p>
<h1><a class="anchor" id="autotoc_md21318"></a>
Instance Methods</h1>
<h2><a class="anchor" id="autotoc_md21319"></a>
<code>Dispatcher.close([callback]): Promise</code></h2>
<p>Closes the dispatcher and gracefully waits for enqueued requests to complete before resolving.</p>
<p>Arguments:</p>
<ul>
<li><b>callback</b> <code>(error: Error | null, data: null) =&gt; void</code> (optional)</li>
</ul>
<p>Returns: <code>void | Promise&lt;null&gt;</code> - Only returns a <code>Promise</code> if no <code>callback</code> argument was passed</p>
<div class="fragment"><div class="line">dispatcher.close() // -&gt; Promise</div>
<div class="line">dispatcher.close(() =&gt; {}) // -&gt; void</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md21320"></a>
Example - Request resolves before Client closes</h3>
<div class="fragment"><div class="line">import { createServer } from &#39;http&#39;</div>
<div class="line">import { Client } from &#39;undici&#39;</div>
<div class="line">import { once } from &#39;events&#39;</div>
<div class="line"> </div>
<div class="line">const server = createServer((request, response) =&gt; {</div>
<div class="line">  response.end(&#39;undici&#39;)</div>
<div class="line">}).listen()</div>
<div class="line"> </div>
<div class="line">await once(server, &#39;listening&#39;)</div>
<div class="line"> </div>
<div class="line">const client = new Client(`http://localhost:${server.address().port}`)</div>
<div class="line"> </div>
<div class="line">try {</div>
<div class="line">  const { body } = await client.request({</div>
<div class="line">      path: &#39;/&#39;,</div>
<div class="line">      method: &#39;GET&#39;</div>
<div class="line">  })</div>
<div class="line">  body.setEncoding(&#39;utf8&#39;)</div>
<div class="line">  body.on(&#39;data&#39;, console.log)</div>
<div class="line">} catch (error) {}</div>
<div class="line"> </div>
<div class="line">await client.close()</div>
<div class="line"> </div>
<div class="line">console.log(&#39;Client closed&#39;)</div>
<div class="line">server.close()</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md21321"></a>
<code>Dispatcher.connect(options[, callback])</code></h2>
<p>Starts two-way communications with the requested resource using <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/CONNECT">HTTP CONNECT</a>.</p>
<p>Arguments:</p>
<ul>
<li><b>options</b> <code>ConnectOptions</code></li>
<li><b>callback</b> <code>(err: Error | null, data: ConnectData | null) =&gt; void</code> (optional)</li>
</ul>
<p>Returns: <code>void | Promise&lt;ConnectData&gt;</code> - Only returns a <code>Promise</code> if no <code>callback</code> argument was passed</p>
<h3><a class="anchor" id="autotoc_md21322"></a>
Parameter: <code>ConnectOptions</code></h3>
<ul>
<li><b>path</b> <code>string</code></li>
<li><b>headers</b> <code>UndiciHeaders</code> (optional) - Default: <code>null</code></li>
<li><b>signal</b> <code>AbortSignal | events.EventEmitter | null</code> (optional) - Default: <code>null</code></li>
<li><b>opaque</b> <code>unknown</code> (optional) - This argument parameter is passed through to <code>ConnectData</code></li>
</ul>
<h3><a class="anchor" id="autotoc_md21323"></a>
Parameter: <code>ConnectData</code></h3>
<ul>
<li><b>statusCode</b> <code>number</code></li>
<li><b>headers</b> <code>Record&lt;string, string | string[] | undefined&gt;</code></li>
<li><b>socket</b> <code>stream.Duplex</code></li>
<li><b>opaque</b> <code>unknown</code></li>
</ul>
<h3><a class="anchor" id="autotoc_md21324"></a>
Example - Connect request with echo</h3>
<div class="fragment"><div class="line">import { createServer } from &#39;http&#39;</div>
<div class="line">import { Client } from &#39;undici&#39;</div>
<div class="line">import { once } from &#39;events&#39;</div>
<div class="line"> </div>
<div class="line">const server = createServer((request, response) =&gt; {</div>
<div class="line">  throw Error(&#39;should never get here&#39;)</div>
<div class="line">}).listen()</div>
<div class="line"> </div>
<div class="line">server.on(&#39;connect&#39;, (req, socket, head) =&gt; {</div>
<div class="line">  socket.write(&#39;HTTP/1.1 200 Connection established\r\n\r\n&#39;)</div>
<div class="line"> </div>
<div class="line">  let data = head.toString()</div>
<div class="line">  socket.on(&#39;data&#39;, (buf) =&gt; {</div>
<div class="line">    data += buf.toString()</div>
<div class="line">  })</div>
<div class="line"> </div>
<div class="line">  socket.on(&#39;end&#39;, () =&gt; {</div>
<div class="line">    socket.end(data)</div>
<div class="line">  })</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">await once(server, &#39;listening&#39;)</div>
<div class="line"> </div>
<div class="line">const client = new Client(`http://localhost:${server.address().port}`)</div>
<div class="line"> </div>
<div class="line">try {</div>
<div class="line">  const { socket } = await client.connect({</div>
<div class="line">    path: &#39;/&#39;</div>
<div class="line">  })</div>
<div class="line">  const wanted = &#39;Body&#39;</div>
<div class="line">  let data = &#39;&#39;</div>
<div class="line">  socket.on(&#39;data&#39;, d =&gt; { data += d })</div>
<div class="line">  socket.on(&#39;end&#39;, () =&gt; {</div>
<div class="line">    console.log(`Data received: ${data.toString()} | Data wanted: ${wanted}`)</div>
<div class="line">    client.close()</div>
<div class="line">    server.close()</div>
<div class="line">  })</div>
<div class="line">  socket.write(wanted)</div>
<div class="line">  socket.end()</div>
<div class="line">} catch (error) { }</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md21325"></a>
<code>Dispatcher.destroy([error, callback]): Promise</code></h2>
<p>Destroy the dispatcher abruptly with the given error. All the pending and running requests will be asynchronously aborted and error. Since this operation is asynchronously dispatched there might still be some progress on dispatched requests.</p>
<p>Both arguments are optional; the method can be called in four different ways:</p>
<p>Arguments:</p>
<ul>
<li><b>error</b> <code>Error | null</code> (optional)</li>
<li><b>callback</b> <code>(error: Error | null, data: null) =&gt; void</code> (optional)</li>
</ul>
<p>Returns: <code>void | Promise&lt;void&gt;</code> - Only returns a <code>Promise</code> if no <code>callback</code> argument was passed</p>
<div class="fragment"><div class="line">dispatcher.destroy() // -&gt; Promise</div>
<div class="line">dispatcher.destroy(new Error()) // -&gt; Promise</div>
<div class="line">dispatcher.destroy(() =&gt; {}) // -&gt; void</div>
<div class="line">dispatcher.destroy(new Error(), () =&gt; {}) // -&gt; void</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md21326"></a>
Example - Request is aborted when Client is destroyed</h3>
<div class="fragment"><div class="line">import { createServer } from &#39;http&#39;</div>
<div class="line">import { Client } from &#39;undici&#39;</div>
<div class="line">import { once } from &#39;events&#39;</div>
<div class="line"> </div>
<div class="line">const server = createServer((request, response) =&gt; {</div>
<div class="line">  response.end()</div>
<div class="line">}).listen()</div>
<div class="line"> </div>
<div class="line">await once(server, &#39;listening&#39;)</div>
<div class="line"> </div>
<div class="line">const client = new Client(`http://localhost:${server.address().port}`)</div>
<div class="line"> </div>
<div class="line">try {</div>
<div class="line">  const request = client.request({</div>
<div class="line">    path: &#39;/&#39;,</div>
<div class="line">    method: &#39;GET&#39;</div>
<div class="line">  })</div>
<div class="line">  client.destroy()</div>
<div class="line">    .then(() =&gt; {</div>
<div class="line">      console.log(&#39;Client destroyed&#39;)</div>
<div class="line">      server.close()</div>
<div class="line">    })</div>
<div class="line">  await request</div>
<div class="line">} catch (error) {</div>
<div class="line">  console.error(error)</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md21327"></a>
<code>Dispatcher.dispatch(options, handler)</code></h2>
<p>This is the low level API which all the preceding APIs are implemented on top of. This API is expected to evolve through semver-major versions and is less stable than the preceding higher level APIs. It is primarily intended for library developers who implement higher level APIs on top of this.</p>
<p>Arguments:</p>
<ul>
<li><b>options</b> <code>DispatchOptions</code></li>
<li><b>handler</b> <code>DispatchHandler</code></li>
</ul>
<p>Returns: <code>Boolean</code> - <code>false</code> if dispatcher is busy and further dispatch calls won't make any progress until the &lsquo;'drain&rsquo;` event has been emitted.</p>
<h3><a class="anchor" id="autotoc_md21328"></a>
Parameter: <code>DispatchOptions</code></h3>
<ul>
<li><b>origin</b> <code>string | URL</code></li>
<li><b>path</b> <code>string</code></li>
<li><b>method</b> <code>string</code></li>
<li><b>reset</b> <code>boolean</code> (optional) - Default: <code>false</code> - If <code>false</code>, the request will attempt to create a long-living connection by sending the <code>connection: keep-alive</code> header,otherwise will attempt to close it immediately after response by sending <code>connection: close</code> within the request and closing the socket afterwards.</li>
<li><b>body</b> <code>string | Buffer | Uint8Array | stream.Readable | Iterable | AsyncIterable | null</code> (optional) - Default: <code>null</code></li>
<li><b>headers</b> <code>UndiciHeaders | string[]</code> (optional) - Default: <code>null</code>.</li>
<li><b>query</b> <code>Record&lt;string, any&gt; | null</code> (optional) - Default: <code>null</code> - Query string params to be embedded in the request URL. Note that both keys and values of query are encoded using <code>encodeURIComponent</code>. If for some reason you need to send them unencoded, embed query params into path directly instead.</li>
<li><b>idempotent</b> <code>boolean</code> (optional) - Default: <code>true</code> if <code>method</code> is &lsquo;'HEAD&rsquo;<code>or</code>'GET'<code>- Whether the requests can be safely retried or not. If</code>false<code>the request won't be sent until all preceding requests in the pipeline has completed.</code></li>
<li><code>**blocking**</code>boolean&lt;tt&gt;(optional) - Default:</li>
</ul>
<p>false<code>- Whether the response is expected to take a long time and would end up blocking the pipeline. When this is set to</code>true<code>further pipelining will be avoided on the same connection until headers have been received.</p><ul>
<li>**upgrade**</li>
</ul>
<p></code>string | null&lt;tt&gt;(optional) - Default:null<code>- Upgrade the request. Should be used to specify the kind of upgrade i.e.</code>'Websocket'<code>.</p><ul>
<li>**bodyTimeout**</li>
</ul>
<p></code>number | null&lt;tt&gt;(optional) - The timeout after which a request will time out, in milliseconds. Monitors time between receiving body data. Use0<code>to disable it entirely. Defaults to 300 seconds.</p><ul>
<li>**headersTimeout**</li>
</ul>
<p></code>number | null&lt;tt&gt;(optional) - The amount of time, in milliseconds, the parser will wait to receive the complete HTTP headers while not sending the request. Defaults to 300 seconds.</p><ul>
<li>**throwOnError**</li>
</ul>
<p>boolean&lt;tt&gt;(optional) - Default:false<code>- Whether Undici should throw an error upon receiving a 4xx or 5xx response from the server.</p><ul>
<li>**expectContinue**</li>
</ul>
<p></code>boolean&lt;tt&gt;(optional) - Default:false` - For H2, it appends the expect: 100-continue header, and halts the request body until a 100-continue is received from the remote server</p>
<h3><a class="anchor" id="autotoc_md21329"></a>
Parameter: <code>DispatchHandler</code></h3>
<ul>
<li><b>onConnect</b> <code>(abort: () =&gt; void, context: object) =&gt; void</code> - Invoked before request is dispatched on socket. May be invoked multiple times when a request is retried when the request at the head of the pipeline fails.</li>
<li><b>onError</b> <code>(error: Error) =&gt; void</code> - Invoked when an error has occurred. May not throw.</li>
<li><b>onUpgrade</b> <code>(statusCode: number, headers: Buffer[], socket: Duplex) =&gt; void</code> (optional) - Invoked when request is upgraded. Required if <code>DispatchOptions.upgrade</code> is defined or &lsquo;DispatchOptions.method === 'CONNECT&rsquo;<code>.</code></li>
<li><code>**onHeaders**</code>(statusCode: number, headers: Buffer[], resume: () =&gt; void, statusText: string) =&gt; boolean<code>- Invoked when statusCode and headers have been received. May be invoked multiple times due to 1xx informational headers. Not required for</code>upgrade<code>requests.</code></li>
<li><code>**onData**</code>(chunk: Buffer) =&gt; boolean<code>- Invoked when response payload data is received. Not required for</code>upgrade<code>requests.</code></li>
<li><code>**onComplete**</code>(trailers: Buffer[]) =&gt; void<code>- Invoked when response payload and trailers have been received and the request has completed. Not required for</code>upgrade<code>requests.</code></li>
<li><code>**onBodySent**</code>(chunk: string | Buffer | Uint8Array) =&gt; void` - Invoked when a body chunk is sent to the server. Not required. For a stream or iterable body this will be invoked for every chunk. For other body types, it will be invoked once after the body is sent.</li>
</ul>
<h3><a class="anchor" id="autotoc_md21330"></a>
Example 1 - Dispatch GET request</h3>
<div class="fragment"><div class="line">import { createServer } from &#39;http&#39;</div>
<div class="line">import { Client } from &#39;undici&#39;</div>
<div class="line">import { once } from &#39;events&#39;</div>
<div class="line"> </div>
<div class="line">const server = createServer((request, response) =&gt; {</div>
<div class="line">  response.end(&#39;Hello, World!&#39;)</div>
<div class="line">}).listen()</div>
<div class="line"> </div>
<div class="line">await once(server, &#39;listening&#39;)</div>
<div class="line"> </div>
<div class="line">const client = new Client(`http://localhost:${server.address().port}`)</div>
<div class="line"> </div>
<div class="line">const data = []</div>
<div class="line"> </div>
<div class="line">client.dispatch({</div>
<div class="line">  path: &#39;/&#39;,</div>
<div class="line">  method: &#39;GET&#39;,</div>
<div class="line">  headers: {</div>
<div class="line">    &#39;x-foo&#39;: &#39;bar&#39;</div>
<div class="line">  }</div>
<div class="line">}, {</div>
<div class="line">  onConnect: () =&gt; {</div>
<div class="line">    console.log(&#39;Connected!&#39;)</div>
<div class="line">  },</div>
<div class="line">  onError: (error) =&gt; {</div>
<div class="line">    console.error(error)</div>
<div class="line">  },</div>
<div class="line">  onHeaders: (statusCode, headers) =&gt; {</div>
<div class="line">    console.log(`onHeaders | statusCode: ${statusCode} | headers: ${headers}`)</div>
<div class="line">  },</div>
<div class="line">  onData: (chunk) =&gt; {</div>
<div class="line">    console.log(&#39;onData: chunk received&#39;)</div>
<div class="line">    data.push(chunk)</div>
<div class="line">  },</div>
<div class="line">  onComplete: (trailers) =&gt; {</div>
<div class="line">    console.log(`onComplete | trailers: ${trailers}`)</div>
<div class="line">    const res = Buffer.concat(data).toString(&#39;utf8&#39;)</div>
<div class="line">    console.log(`Data: ${res}`)</div>
<div class="line">    client.close()</div>
<div class="line">    server.close()</div>
<div class="line">  }</div>
<div class="line">})</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md21331"></a>
Example 2 - Dispatch Upgrade Request</h3>
<div class="fragment"><div class="line">import { createServer } from &#39;http&#39;</div>
<div class="line">import { Client } from &#39;undici&#39;</div>
<div class="line">import { once } from &#39;events&#39;</div>
<div class="line"> </div>
<div class="line">const server = createServer((request, response) =&gt; {</div>
<div class="line">  response.end()</div>
<div class="line">}).listen()</div>
<div class="line"> </div>
<div class="line">await once(server, &#39;listening&#39;)</div>
<div class="line"> </div>
<div class="line">server.on(&#39;upgrade&#39;, (request, socket, head) =&gt; {</div>
<div class="line">  console.log(&#39;Node.js Server - upgrade event&#39;)</div>
<div class="line">  socket.write(&#39;HTTP/1.1 101 Web Socket Protocol Handshake\r\n&#39;)</div>
<div class="line">  socket.write(&#39;Upgrade: WebSocket\r\n&#39;)</div>
<div class="line">  socket.write(&#39;Connection: Upgrade\r\n&#39;)</div>
<div class="line">  socket.write(&#39;\r\n&#39;)</div>
<div class="line">  socket.end()</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">const client = new Client(`http://localhost:${server.address().port}`)</div>
<div class="line"> </div>
<div class="line">client.dispatch({</div>
<div class="line">  path: &#39;/&#39;,</div>
<div class="line">  method: &#39;GET&#39;,</div>
<div class="line">  upgrade: &#39;websocket&#39;</div>
<div class="line">}, {</div>
<div class="line">  onConnect: () =&gt; {</div>
<div class="line">    console.log(&#39;Undici Client - onConnect&#39;)</div>
<div class="line">  },</div>
<div class="line">  onError: (error) =&gt; {</div>
<div class="line">    console.log(&#39;onError&#39;) // shouldn&#39;t print</div>
<div class="line">  },</div>
<div class="line">  onUpgrade: (statusCode, headers, socket) =&gt; {</div>
<div class="line">    console.log(&#39;Undici Client - onUpgrade&#39;)</div>
<div class="line">    console.log(`onUpgrade Headers: ${headers}`)</div>
<div class="line">    socket.on(&#39;data&#39;, buffer =&gt; {</div>
<div class="line">      console.log(buffer.toString(&#39;utf8&#39;))</div>
<div class="line">    })</div>
<div class="line">    socket.on(&#39;end&#39;, () =&gt; {</div>
<div class="line">      client.close()</div>
<div class="line">      server.close()</div>
<div class="line">    })</div>
<div class="line">    socket.end()</div>
<div class="line">  }</div>
<div class="line">})</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md21332"></a>
Example 3 - Dispatch POST request</h3>
<div class="fragment"><div class="line">import { createServer } from &#39;http&#39;</div>
<div class="line">import { Client } from &#39;undici&#39;</div>
<div class="line">import { once } from &#39;events&#39;</div>
<div class="line"> </div>
<div class="line">const server = createServer((request, response) =&gt; {</div>
<div class="line">  request.on(&#39;data&#39;, (data) =&gt; {</div>
<div class="line">    console.log(`Request Data: ${data.toString(&#39;utf8&#39;)}`)</div>
<div class="line">    const body = JSON.parse(data)</div>
<div class="line">    body.message = &#39;World&#39;</div>
<div class="line">    response.end(JSON.stringify(body))</div>
<div class="line">  })</div>
<div class="line">}).listen()</div>
<div class="line"> </div>
<div class="line">await once(server, &#39;listening&#39;)</div>
<div class="line"> </div>
<div class="line">const client = new Client(`http://localhost:${server.address().port}`)</div>
<div class="line"> </div>
<div class="line">const data = []</div>
<div class="line"> </div>
<div class="line">client.dispatch({</div>
<div class="line">  path: &#39;/&#39;,</div>
<div class="line">  method: &#39;POST&#39;,</div>
<div class="line">  headers: {</div>
<div class="line">    &#39;content-type&#39;: &#39;application/json&#39;</div>
<div class="line">  },</div>
<div class="line">  body: JSON.stringify({ message: &#39;Hello&#39; })</div>
<div class="line">}, {</div>
<div class="line">  onConnect: () =&gt; {</div>
<div class="line">    console.log(&#39;Connected!&#39;)</div>
<div class="line">  },</div>
<div class="line">  onError: (error) =&gt; {</div>
<div class="line">    console.error(error)</div>
<div class="line">  },</div>
<div class="line">  onHeaders: (statusCode, headers) =&gt; {</div>
<div class="line">    console.log(`onHeaders | statusCode: ${statusCode} | headers: ${headers}`)</div>
<div class="line">  },</div>
<div class="line">  onData: (chunk) =&gt; {</div>
<div class="line">    console.log(&#39;onData: chunk received&#39;)</div>
<div class="line">    data.push(chunk)</div>
<div class="line">  },</div>
<div class="line">  onComplete: (trailers) =&gt; {</div>
<div class="line">    console.log(`onComplete | trailers: ${trailers}`)</div>
<div class="line">    const res = Buffer.concat(data).toString(&#39;utf8&#39;)</div>
<div class="line">    console.log(`Response Data: ${res}`)</div>
<div class="line">    client.close()</div>
<div class="line">    server.close()</div>
<div class="line">  }</div>
<div class="line">})</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md21333"></a>
<code>Dispatcher.pipeline(options, handler)</code></h2>
<p>For easy use with <a href="https://nodejs.org/api/stream.html#stream_stream_pipeline_source_transforms_destination_callback">stream.pipeline</a>. The <code>handler</code> argument should return a <code>Readable</code> from which the result will be read. Usually it should just return the <code>body</code> argument unless some kind of transformation needs to be performed based on e.g. <code>headers</code> or <code>statusCode</code>. The <code>handler</code> should validate the response and save any required state. If there is an error, it should be thrown. The function returns a <code>Duplex</code> which writes to the request and reads from the response.</p>
<p>Arguments:</p>
<ul>
<li><b>options</b> <code>PipelineOptions</code></li>
<li><b>handler</b> <code>(data: PipelineHandlerData) =&gt; stream.Readable</code></li>
</ul>
<p>Returns: <code>stream.Duplex</code></p>
<h3><a class="anchor" id="autotoc_md21334"></a>
Parameter: PipelineOptions</h3>
<p>Extends: `RequestOptions`</p>
<ul>
<li><b>objectMode</b> <code>boolean</code> (optional) - Default: <code>false</code> - Set to <code>true</code> if the <code>handler</code> will return an object stream.</li>
</ul>
<h3><a class="anchor" id="autotoc_md21335"></a>
Parameter: PipelineHandlerData</h3>
<ul>
<li><b>statusCode</b> <code>number</code></li>
<li><b>headers</b> <code>Record&lt;string, string | string[] | undefined&gt;</code></li>
<li><b>opaque</b> <code>unknown</code></li>
<li><b>body</b> <code>stream.Readable</code></li>
<li><b>context</b> <code>object</code></li>
<li><b>onInfo</b> <code>({statusCode: number, headers: Record&lt;string, string | string[]&gt;}) =&gt; void | null</code> (optional) - Default: <code>null</code> - Callback collecting all the info headers (HTTP 100-199) received.</li>
</ul>
<h3><a class="anchor" id="autotoc_md21336"></a>
Example 1 - Pipeline Echo</h3>
<div class="fragment"><div class="line">import { Readable, Writable, PassThrough, pipeline } from &#39;stream&#39;</div>
<div class="line">import { createServer } from &#39;http&#39;</div>
<div class="line">import { Client } from &#39;undici&#39;</div>
<div class="line">import { once } from &#39;events&#39;</div>
<div class="line"> </div>
<div class="line">const server = createServer((request, response) =&gt; {</div>
<div class="line">  request.pipe(response)</div>
<div class="line">}).listen()</div>
<div class="line"> </div>
<div class="line">await once(server, &#39;listening&#39;)</div>
<div class="line"> </div>
<div class="line">const client = new Client(`http://localhost:${server.address().port}`)</div>
<div class="line"> </div>
<div class="line">let res = &#39;&#39;</div>
<div class="line"> </div>
<div class="line">pipeline(</div>
<div class="line">  new Readable({</div>
<div class="line">    read () {</div>
<div class="line">      this.push(Buffer.from(&#39;undici&#39;))</div>
<div class="line">      this.push(null)</div>
<div class="line">    }</div>
<div class="line">  }),</div>
<div class="line">  client.pipeline({</div>
<div class="line">    path: &#39;/&#39;,</div>
<div class="line">    method: &#39;GET&#39;</div>
<div class="line">  }, ({ statusCode, headers, body }) =&gt; {</div>
<div class="line">    console.log(`response received ${statusCode}`)</div>
<div class="line">    console.log(&#39;headers&#39;, headers)</div>
<div class="line">    return pipeline(body, new PassThrough(), () =&gt; {})</div>
<div class="line">  }),</div>
<div class="line">  new Writable({</div>
<div class="line">    write (chunk, _, callback) {</div>
<div class="line">      res += chunk.toString()</div>
<div class="line">      callback()</div>
<div class="line">    },</div>
<div class="line">    final (callback) {</div>
<div class="line">      console.log(`Response pipelined to writable: ${res}`)</div>
<div class="line">      callback()</div>
<div class="line">    }</div>
<div class="line">  }),</div>
<div class="line">  error =&gt; {</div>
<div class="line">    if (error) {</div>
<div class="line">      console.error(error)</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    client.close()</div>
<div class="line">    server.close()</div>
<div class="line">  }</div>
<div class="line">)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md21337"></a>
<code>Dispatcher.request(options[, callback])</code></h2>
<p>Performs a HTTP request.</p>
<p>Non-idempotent requests will not be pipelined in order to avoid indirect failures.</p>
<p>Idempotent requests will be automatically retried if they fail due to indirect failure from the request at the head of the pipeline. This does not apply to idempotent requests with a stream request body.</p>
<p>All response bodies must always be fully consumed or destroyed.</p>
<p>Arguments:</p>
<ul>
<li><b>options</b> <code>RequestOptions</code></li>
<li><b>callback</b> <code>(error: Error | null, data: ResponseData) =&gt; void</code> (optional)</li>
</ul>
<p>Returns: <code>void | Promise&lt;ResponseData&gt;</code> - Only returns a <code>Promise</code> if no <code>callback</code> argument was passed.</p>
<h3><a class="anchor" id="autotoc_md21338"></a>
Parameter: <code>RequestOptions</code></h3>
<p>Extends: `DispatchOptions`</p>
<ul>
<li><b>opaque</b> <code>unknown</code> (optional) - Default: <code>null</code> - Used for passing through context to <code>ResponseData</code>.</li>
<li><b>signal</b> <code>AbortSignal | events.EventEmitter | null</code> (optional) - Default: <code>null</code>.</li>
<li><b>onInfo</b> <code>({statusCode: number, headers: Record&lt;string, string | string[]&gt;}) =&gt; void | null</code> (optional) - Default: <code>null</code> - Callback collecting all the info headers (HTTP 100-199) received.</li>
</ul>
<p>The <code>RequestOptions.method</code> property should not be value &lsquo;'CONNECT&rsquo;`.</p>
<h3><a class="anchor" id="autotoc_md21339"></a>
Parameter: <code>ResponseData</code></h3>
<ul>
<li><b>statusCode</b> <code>number</code></li>
<li><b>headers</b> <code>Record&lt;string, string | string[]&gt;</code> - Note that all header keys are lower-cased, e. g. <code>content-type</code>.</li>
<li><b>body</b> <code>stream.Readable</code> which also implements <a href="https://fetch.spec.whatwg.org/#body-mixin">the body mixin from the Fetch Standard</a>.</li>
<li><b>trailers</b> <code>Record&lt;string, string&gt;</code> - This object starts out as empty and will be mutated to contain trailers after <code>body</code> has emitted &lsquo;'end&rsquo;<code>.</code></li>
<li><code>**opaque**</code>unknown<code></code></li>
<li><code>**context**</code>object`</li>
</ul>
<p><code>body</code> contains the following additional <a href="https://fetch.spec.whatwg.org/#body-mixin">body mixin</a> methods and properties:</p>
<ul>
<li><code>text()</code></li>
<li><code>json()</code></li>
<li><code>arrayBuffer()</code></li>
<li><code>body</code></li>
<li><code>bodyUsed</code></li>
</ul>
<p><code>body</code> can not be consumed twice. For example, calling <code>text()</code> after <code>json()</code> throws <code>TypeError</code>.</p>
<p><code>body</code> contains the following additional extensions:</p>
<ul>
<li><code>dump({ limit: Integer })</code>, dump the response by reading up to <code>limit</code> bytes without killing the socket (optional) - Default: 262144.</li>
</ul>
<p>Note that body will still be a <code>Readable</code> even if it is empty, but attempting to deserialize it with <code>json()</code> will result in an exception. Recommended way to ensure there is a body to deserialize is to check if status code is not 204, and <code>content-type</code> header starts with <code>application/json</code>.</p>
<h3><a class="anchor" id="autotoc_md21340"></a>
Example 1 - Basic GET Request</h3>
<div class="fragment"><div class="line">import { createServer } from &#39;http&#39;</div>
<div class="line">import { Client } from &#39;undici&#39;</div>
<div class="line">import { once } from &#39;events&#39;</div>
<div class="line"> </div>
<div class="line">const server = createServer((request, response) =&gt; {</div>
<div class="line">  response.end(&#39;Hello, World!&#39;)</div>
<div class="line">}).listen()</div>
<div class="line"> </div>
<div class="line">await once(server, &#39;listening&#39;)</div>
<div class="line"> </div>
<div class="line">const client = new Client(`http://localhost:${server.address().port}`)</div>
<div class="line"> </div>
<div class="line">try {</div>
<div class="line">  const { body, headers, statusCode, trailers } = await client.request({</div>
<div class="line">    path: &#39;/&#39;,</div>
<div class="line">    method: &#39;GET&#39;</div>
<div class="line">  })</div>
<div class="line">  console.log(`response received ${statusCode}`)</div>
<div class="line">  console.log(&#39;headers&#39;, headers)</div>
<div class="line">  body.setEncoding(&#39;utf8&#39;)</div>
<div class="line">  body.on(&#39;data&#39;, console.log)</div>
<div class="line">  body.on(&#39;end&#39;, () =&gt; {</div>
<div class="line">    console.log(&#39;trailers&#39;, trailers)</div>
<div class="line">  })</div>
<div class="line"> </div>
<div class="line">  client.close()</div>
<div class="line">  server.close()</div>
<div class="line">} catch (error) {</div>
<div class="line">  console.error(error)</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md21341"></a>
Example 2 - Aborting a request</h3>
<blockquote class="doxtable">
<p>Node.js v15+ is required to run this example </p>
</blockquote>
<div class="fragment"><div class="line">import { createServer } from &#39;http&#39;</div>
<div class="line">import { Client } from &#39;undici&#39;</div>
<div class="line">import { once } from &#39;events&#39;</div>
<div class="line"> </div>
<div class="line">const server = createServer((request, response) =&gt; {</div>
<div class="line">  response.end(&#39;Hello, World!&#39;)</div>
<div class="line">}).listen()</div>
<div class="line"> </div>
<div class="line">await once(server, &#39;listening&#39;)</div>
<div class="line"> </div>
<div class="line">const client = new Client(`http://localhost:${server.address().port}`)</div>
<div class="line">const abortController = new AbortController()</div>
<div class="line"> </div>
<div class="line">try {</div>
<div class="line">  client.request({</div>
<div class="line">    path: &#39;/&#39;,</div>
<div class="line">    method: &#39;GET&#39;,</div>
<div class="line">    signal: abortController.signal</div>
<div class="line">  })</div>
<div class="line">} catch (error) {</div>
<div class="line">  console.error(error) // should print an RequestAbortedError</div>
<div class="line">  client.close()</div>
<div class="line">  server.close()</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">abortController.abort()</div>
</div><!-- fragment --><p>Alternatively, any <code>EventEmitter</code> that emits an &lsquo;'abort&rsquo;` event may be used as an abort controller:</p>
<div class="fragment"><div class="line">import { createServer } from &#39;http&#39;</div>
<div class="line">import { Client } from &#39;undici&#39;</div>
<div class="line">import EventEmitter, { once } from &#39;events&#39;</div>
<div class="line"> </div>
<div class="line">const server = createServer((request, response) =&gt; {</div>
<div class="line">  response.end(&#39;Hello, World!&#39;)</div>
<div class="line">}).listen()</div>
<div class="line"> </div>
<div class="line">await once(server, &#39;listening&#39;)</div>
<div class="line"> </div>
<div class="line">const client = new Client(`http://localhost:${server.address().port}`)</div>
<div class="line">const ee = new EventEmitter()</div>
<div class="line"> </div>
<div class="line">try {</div>
<div class="line">  client.request({</div>
<div class="line">    path: &#39;/&#39;,</div>
<div class="line">    method: &#39;GET&#39;,</div>
<div class="line">    signal: ee</div>
<div class="line">  })</div>
<div class="line">} catch (error) {</div>
<div class="line">  console.error(error) // should print an RequestAbortedError</div>
<div class="line">  client.close()</div>
<div class="line">  server.close()</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">ee.emit(&#39;abort&#39;)</div>
</div><!-- fragment --><p>Destroying the request or response body will have the same effect.</p>
<div class="fragment"><div class="line">import { createServer } from &#39;http&#39;</div>
<div class="line">import { Client } from &#39;undici&#39;</div>
<div class="line">import { once } from &#39;events&#39;</div>
<div class="line"> </div>
<div class="line">const server = createServer((request, response) =&gt; {</div>
<div class="line">  response.end(&#39;Hello, World!&#39;)</div>
<div class="line">}).listen()</div>
<div class="line"> </div>
<div class="line">await once(server, &#39;listening&#39;)</div>
<div class="line"> </div>
<div class="line">const client = new Client(`http://localhost:${server.address().port}`)</div>
<div class="line"> </div>
<div class="line">try {</div>
<div class="line">  const { body } = await client.request({</div>
<div class="line">    path: &#39;/&#39;,</div>
<div class="line">    method: &#39;GET&#39;</div>
<div class="line">  })</div>
<div class="line">  body.destroy()</div>
<div class="line">} catch (error) {</div>
<div class="line">  console.error(error) // should print an RequestAbortedError</div>
<div class="line">  client.close()</div>
<div class="line">  server.close()</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md21342"></a>
<code>Dispatcher.stream(options, factory[, callback])</code></h2>
<p>A faster version of <code>Dispatcher.request</code>. This method expects the second argument <code>factory</code> to return a <a href="https://nodejs.org/api/stream.html#stream_class_stream_writable"><code>stream.Writable</code></a> stream which the response will be written to. This improves performance by avoiding creating an intermediate <a href="https://nodejs.org/api/stream.html#stream_readable_streams"><code>stream.Readable</code></a> stream when the user expects to directly pipe the response body to a <a href="https://nodejs.org/api/stream.html#stream_class_stream_writable"><code>stream.Writable</code></a> stream.</p>
<p>As demonstrated in Example 1 - Basic GET stream request, it is recommended to use the <code>option.opaque</code> property to avoid creating a closure for the <code>factory</code> method. This pattern works well with Node.js Web Frameworks such as <a href="https://fastify.io">Fastify</a>. See Example 2 - Stream to Fastify Response for more details.</p>
<p>Arguments:</p>
<ul>
<li><b>options</b> <code>RequestOptions</code></li>
<li><b>factory</b> <code>(data: StreamFactoryData) =&gt; stream.Writable</code></li>
<li><b>callback</b> <code>(error: Error | null, data: StreamData) =&gt; void</code> (optional)</li>
</ul>
<p>Returns: <code>void | Promise&lt;StreamData&gt;</code> - Only returns a <code>Promise</code> if no <code>callback</code> argument was passed</p>
<h3><a class="anchor" id="autotoc_md21343"></a>
Parameter: <code>StreamFactoryData</code></h3>
<ul>
<li><b>statusCode</b> <code>number</code></li>
<li><b>headers</b> <code>Record&lt;string, string | string[] | undefined&gt;</code></li>
<li><b>opaque</b> <code>unknown</code></li>
<li><b>onInfo</b> <code>({statusCode: number, headers: Record&lt;string, string | string[]&gt;}) =&gt; void | null</code> (optional) - Default: <code>null</code> - Callback collecting all the info headers (HTTP 100-199) received.</li>
</ul>
<h3><a class="anchor" id="autotoc_md21344"></a>
Parameter: <code>StreamData</code></h3>
<ul>
<li><b>opaque</b> <code>unknown</code></li>
<li><b>trailers</b> <code>Record&lt;string, string&gt;</code></li>
<li><b>context</b> <code>object</code></li>
</ul>
<h3><a class="anchor" id="autotoc_md21345"></a>
Example 1 - Basic GET stream request</h3>
<div class="fragment"><div class="line">import { createServer } from &#39;http&#39;</div>
<div class="line">import { Client } from &#39;undici&#39;</div>
<div class="line">import { once } from &#39;events&#39;</div>
<div class="line">import { Writable } from &#39;stream&#39;</div>
<div class="line"> </div>
<div class="line">const server = createServer((request, response) =&gt; {</div>
<div class="line">  response.end(&#39;Hello, World!&#39;)</div>
<div class="line">}).listen()</div>
<div class="line"> </div>
<div class="line">await once(server, &#39;listening&#39;)</div>
<div class="line"> </div>
<div class="line">const client = new Client(`http://localhost:${server.address().port}`)</div>
<div class="line"> </div>
<div class="line">const bufs = []</div>
<div class="line"> </div>
<div class="line">try {</div>
<div class="line">  await client.stream({</div>
<div class="line">    path: &#39;/&#39;,</div>
<div class="line">    method: &#39;GET&#39;,</div>
<div class="line">    opaque: { bufs }</div>
<div class="line">  }, ({ statusCode, headers, opaque: { bufs } }) =&gt; {</div>
<div class="line">    console.log(`response received ${statusCode}`)</div>
<div class="line">    console.log(&#39;headers&#39;, headers)</div>
<div class="line">    return new Writable({</div>
<div class="line">      write (chunk, encoding, callback) {</div>
<div class="line">        bufs.push(chunk)</div>
<div class="line">        callback()</div>
<div class="line">      }</div>
<div class="line">    })</div>
<div class="line">  })</div>
<div class="line"> </div>
<div class="line">  console.log(Buffer.concat(bufs).toString(&#39;utf-8&#39;))</div>
<div class="line"> </div>
<div class="line">  client.close()</div>
<div class="line">  server.close()</div>
<div class="line">} catch (error) {</div>
<div class="line">  console.error(error)</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md21346"></a>
Example 2 - Stream to Fastify Response</h3>
<p>In this example, a (fake) request is made to the fastify server using <code>fastify.inject()</code>. This request then executes the fastify route handler which makes a subsequent request to the raw Node.js http server using <code>undici.dispatcher.stream()</code>. The fastify response is passed to the <code>opaque</code> option so that undici can tap into the underlying writable stream using <code>response.raw</code>. This methodology demonstrates how one could use undici and fastify together to create fast-as-possible requests from one backend server to another.</p>
<div class="fragment"><div class="line">import { createServer } from &#39;http&#39;</div>
<div class="line">import { Client } from &#39;undici&#39;</div>
<div class="line">import { once } from &#39;events&#39;</div>
<div class="line">import fastify from &#39;fastify&#39;</div>
<div class="line"> </div>
<div class="line">const nodeServer = createServer((request, response) =&gt; {</div>
<div class="line">  response.end(&#39;Hello, World! From Node.js HTTP Server&#39;)</div>
<div class="line">}).listen()</div>
<div class="line"> </div>
<div class="line">await once(nodeServer, &#39;listening&#39;)</div>
<div class="line"> </div>
<div class="line">console.log(&#39;Node Server listening&#39;)</div>
<div class="line"> </div>
<div class="line">const nodeServerUndiciClient = new Client(`http://localhost:${nodeServer.address().port}`)</div>
<div class="line"> </div>
<div class="line">const fastifyServer = fastify()</div>
<div class="line"> </div>
<div class="line">fastifyServer.route({</div>
<div class="line">  url: &#39;/&#39;,</div>
<div class="line">  method: &#39;GET&#39;,</div>
<div class="line">  handler: (request, response) =&gt; {</div>
<div class="line">    nodeServerUndiciClient.stream({</div>
<div class="line">      path: &#39;/&#39;,</div>
<div class="line">      method: &#39;GET&#39;,</div>
<div class="line">      opaque: response</div>
<div class="line">    }, ({ opaque }) =&gt; opaque.raw)</div>
<div class="line">  }</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">await fastifyServer.listen()</div>
<div class="line"> </div>
<div class="line">console.log(&#39;Fastify Server listening&#39;)</div>
<div class="line"> </div>
<div class="line">const fastifyServerUndiciClient = new Client(`http://localhost:${fastifyServer.server.address().port}`)</div>
<div class="line"> </div>
<div class="line">try {</div>
<div class="line">  const { statusCode, body } = await fastifyServerUndiciClient.request({</div>
<div class="line">    path: &#39;/&#39;,</div>
<div class="line">    method: &#39;GET&#39;</div>
<div class="line">  })</div>
<div class="line"> </div>
<div class="line">  console.log(`response received ${statusCode}`)</div>
<div class="line">  body.setEncoding(&#39;utf8&#39;)</div>
<div class="line">  body.on(&#39;data&#39;, console.log)</div>
<div class="line"> </div>
<div class="line">  nodeServerUndiciClient.close()</div>
<div class="line">  fastifyServerUndiciClient.close()</div>
<div class="line">  fastifyServer.close()</div>
<div class="line">  nodeServer.close()</div>
<div class="line">} catch (error) { }</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md21347"></a>
<code>Dispatcher.upgrade(options[, callback])</code></h2>
<p>Upgrade to a different protocol. Visit <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Protocol_upgrade_mechanism">MDN - HTTP - Protocol upgrade mechanism</a> for more details.</p>
<p>Arguments:</p>
<ul>
<li><b>options</b> <code>UpgradeOptions</code></li>
<li><b>callback</b> <code>(error: Error | null, data: UpgradeData) =&gt; void</code> (optional)</li>
</ul>
<p>Returns: <code>void | Promise&lt;UpgradeData&gt;</code> - Only returns a <code>Promise</code> if no <code>callback</code> argument was passed</p>
<h3><a class="anchor" id="autotoc_md21348"></a>
Parameter: <code>UpgradeOptions</code></h3>
<ul>
<li><b>path</b> <code>string</code></li>
<li><b>method</b> <code>string</code> (optional) - Default: &lsquo;'GET&rsquo;<code></code></li>
<li><code>**headers**</code>UndiciHeaders&lt;tt&gt;(optional) - Default:</li>
</ul>
<p>null<code></p><ul>
<li>**protocol**</li>
</ul>
<p></code>string&lt;tt&gt;(optional) - Default:'Websocket'<code>- A string of comma separated protocols, in descending preference order.</p><ul>
<li>**signal**</li>
</ul>
<p></code>AbortSignal | EventEmitter | null&lt;tt&gt;(optional) - Default:null`</p>
<h3><a class="anchor" id="autotoc_md21349"></a>
Parameter: <code>UpgradeData</code></h3>
<ul>
<li><b>headers</b> <code>http.IncomingHeaders</code></li>
<li><b>socket</b> <code>stream.Duplex</code></li>
<li><b>opaque</b> <code>unknown</code></li>
</ul>
<h3><a class="anchor" id="autotoc_md21350"></a>
Example 1 - Basic Upgrade Request</h3>
<div class="fragment"><div class="line">import { createServer } from &#39;http&#39;</div>
<div class="line">import { Client } from &#39;undici&#39;</div>
<div class="line">import { once } from &#39;events&#39;</div>
<div class="line"> </div>
<div class="line">const server = createServer((request, response) =&gt; {</div>
<div class="line">  response.statusCode = 101</div>
<div class="line">  response.setHeader(&#39;connection&#39;, &#39;upgrade&#39;)</div>
<div class="line">  response.setHeader(&#39;upgrade&#39;, request.headers.upgrade)</div>
<div class="line">  response.end()</div>
<div class="line">}).listen()</div>
<div class="line"> </div>
<div class="line">await once(server, &#39;listening&#39;)</div>
<div class="line"> </div>
<div class="line">const client = new Client(`http://localhost:${server.address().port}`)</div>
<div class="line"> </div>
<div class="line">try {</div>
<div class="line">  const { headers, socket } = await client.upgrade({</div>
<div class="line">    path: &#39;/&#39;,</div>
<div class="line">  })</div>
<div class="line">  socket.on(&#39;end&#39;, () =&gt; {</div>
<div class="line">    console.log(`upgrade: ${headers.upgrade}`) // upgrade: Websocket</div>
<div class="line">    client.close()</div>
<div class="line">    server.close()</div>
<div class="line">  })</div>
<div class="line">  socket.end()</div>
<div class="line">} catch (error) {</div>
<div class="line">  console.error(error)</div>
<div class="line">  client.close()</div>
<div class="line">  server.close()</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md21351"></a>
Instance Events</h1>
<h2><a class="anchor" id="autotoc_md21352"></a>
Event: &lsquo;'connect&rsquo;`</h2>
<p>Parameters:</p>
<ul>
<li><b>origin</b> <code>URL</code></li>
<li><b>targets</b> <code>Array&lt;Dispatcher&gt;</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md21353"></a>
Event: &lsquo;'disconnect&rsquo;`</h2>
<p>Parameters:</p>
<ul>
<li><b>origin</b> <code>URL</code></li>
<li><b>targets</b> <code>Array&lt;Dispatcher&gt;</code></li>
<li><b>error</b> <code>Error</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md21354"></a>
Event: &lsquo;'connectionError&rsquo;`</h2>
<p>Parameters:</p>
<ul>
<li><b>origin</b> <code>URL</code></li>
<li><b>targets</b> <code>Array&lt;Dispatcher&gt;</code></li>
<li><b>error</b> <code>Error</code></li>
</ul>
<p>Emitted when dispatcher fails to connect to origin.</p>
<h2><a class="anchor" id="autotoc_md21355"></a>
Event: &lsquo;'drain&rsquo;`</h2>
<p>Parameters:</p>
<ul>
<li><b>origin</b> <code>URL</code></li>
</ul>
<p>Emitted when dispatcher is no longer busy.</p>
<h1><a class="anchor" id="autotoc_md21356"></a>
Parameter: <code>UndiciHeaders</code></h1>
<ul>
<li><code>Record&lt;string, string | string[] | undefined&gt; | string[] | null</code></li>
</ul>
<p>Header arguments such as <code>options.headers</code> in <a href="Client.md#clientdispatchoptions-handlers"><code>Client.dispatch</code></a> can be specified in two forms; either as an object specified by the <code>Record&lt;string, string | string[] | undefined&gt;</code> (<code>IncomingHttpHeaders</code>) type, or an array of strings. An array representation of a header list must have an even length or an <code>InvalidArgumentError</code> will be thrown.</p>
<p>Keys are lowercase and values are not modified.</p>
<p>Response headers will derive a <code>host</code> from the <code>url</code> of the <a href="Client.md#class-client">Client</a> instance if no <code>host</code> header was previously specified.</p>
<h2><a class="anchor" id="autotoc_md21357"></a>
Example 1 - Object</h2>
<div class="fragment"><div class="line">{</div>
<div class="line">  &#39;content-length&#39;: &#39;123&#39;,</div>
<div class="line">  &#39;content-type&#39;: &#39;text/plain&#39;,</div>
<div class="line">  connection: &#39;keep-alive&#39;,</div>
<div class="line">  host: &#39;mysite.com&#39;,</div>
<div class="line">  accept: &#39;*/*&#39;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md21358"></a>
Example 2 - Array</h2>
<div class="fragment"><div class="line">[</div>
<div class="line">  &#39;content-length&#39;, &#39;123&#39;,</div>
<div class="line">  &#39;content-type&#39;, &#39;text/plain&#39;,</div>
<div class="line">  &#39;connection&#39;, &#39;keep-alive&#39;,</div>
<div class="line">  &#39;host&#39;, &#39;mysite.com&#39;,</div>
<div class="line">  &#39;accept&#39;, &#39;*/*&#39;</div>
<div class="line">]</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
