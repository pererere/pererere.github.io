<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FoodLink: D:/GIT/FoodLink/foodlink.client/node_modules/hdr-histogram-js Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">FoodLink
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dir_abab422251f0a2e39b09d8b80b824d14.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">hdr-histogram-js Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>[![Build Status](<a href="https://travis-ci.org/HdrHistogram/HdrHistogramJS.svg?branch=master">https://travis-ci.org/HdrHistogram/HdrHistogramJS.svg?branch=master</a>)](<a href="https://travis-ci.org/HdrHistogram/HdrHistogramJS">https://travis-ci.org/HdrHistogram/HdrHistogramJS</a>)</p>
<h1><a class="anchor" id="autotoc_md8600"></a>
HdrHistogramJS</h1>
<p>TypeScript port of HdrHistogram for NodeJS and web browsers. <br  />
 Since version 2, HdrHistogramJS comes in 2 flavors: the good old TypeScript implementation and a brand new WebAssembly implementation! <br  />
 This new WebAssembly implementation leverages on AssemblyScript to bring a significant performance boost. Since some caution must be taken using this WebAssembly implementation it is not enabled by default. <br  />
 Check out the WebAssembly section for more details on this topic. <br  />
 Most features from original Java HdrHistogram implementation are implemented, including the following ones:</p>
<ul>
<li>regular latency recording</li>
<li>latency recording with coordinated omissions correction</li>
<li>resizable bucket based histograms</li>
<li>memory optimized packed histograms</li>
<li>add and substract histograms</li>
<li>encoding and decoding compressed histograms</li>
</ul>
<h1><a class="anchor" id="autotoc_md8601"></a>
Dataviz</h1>
<p>HdrHistogramJS allows to display histograms without server-side processing. Hence, within your browser, you can:</p>
<ul>
<li>Display histograms with this slightly modified version of the <a href="https://hdrhistogram.github.io/HdrHistogramJSDemo/plotFiles.html">hdrhistogram plotter</a>. With this one you can use base64 v2 encoded histograms as inputs.</li>
<li>Analyze log files with this <a href="https://hdrhistogram.github.io/HdrHistogramJSDemo/logparser.html">log analyzer</a>, inspired from the original <a href="https://github.com/HdrHistogram/HistogramLogAnalyzer">java/swing based log analyzer</a>.</li>
</ul>
<h1><a class="anchor" id="autotoc_md8602"></a>
Getting started</h1>
<p>This library is packaged as a UMD module, hence you can use it directly from JavaScript within a browser. To do so, you can simply include HdrHistogramJS file from github's release page:</p>
<div class="fragment"><div class="line">&lt;script src=&quot;https://github.com/HdrHistogram/HdrHistogramJS/releases/download/v2.0.1/hdrhistogram.umd.js&quot;&gt;&lt;/script&gt;</div>
</div><!-- fragment --><p>Then you will have access to classes and functions of the APIs using "hdr" prefix.</p>
<p>You can also use HdrHistogramJS as a commonjs NodeJS module. Using npm you can get HdrHIstogramJS with the following command:</p>
<div class="fragment"><div class="line">npm i hdr-histogram-js</div>
</div><!-- fragment --><p>Or if you like yarn better:</p>
<div class="fragment"><div class="line">yarn add hdr-histogram-js</div>
</div><!-- fragment --><p>Note for TypeScript developers: since HdrHistogramJS has been written in TypeScript, definition files are embedded, no additional task is needed to get them.</p>
<h1><a class="anchor" id="autotoc_md8603"></a>
API</h1>
<p>The examples below use ES6 syntax. You can check out demo sources for examples on how to use HdrHistogram directly within a browser, you should not have any surprise though.</p>
<h2><a class="anchor" id="autotoc_md8604"></a>
Instantiate an histogram</h2>
<p>HdrHistogramJS provides several histogram implementations. The simplest way to get a new histogram instance is to use the <em>build()</em> function. Here is how to use it:</p>
<div class="fragment"><div class="line">import * as hdr from &quot;hdr-histogram-js&quot;</div>
<div class="line"> </div>
<div class="line">const histogram = hdr.build();</div>
</div><!-- fragment --><p>If you need more control on the memory footprint of the instantiated histogram, you can be more specific using and optionnal build request parameter:</p>
<div class="fragment"><div class="line">import * as hdr from &quot;hdr-histogram-js&quot;</div>
<div class="line"> </div>
<div class="line">const histogram</div>
<div class="line">  = hdr.build(</div>
<div class="line">    {</div>
<div class="line">      bitBucketSize: 32,                // may be 8, 16, 32, 64 or &#39;packed&#39;</div>
<div class="line">      autoResize: true,                 // default value is true</div>
<div class="line">      lowestDiscernibleValue: 1,        // default value is also 1</div>
<div class="line">      highestTrackableValue: 2,         // can increase up to Number.MAX_SAFE_INTEGER</div>
<div class="line">      numberOfSignificantValueDigits: 3 // Number between 1 and 5 (inclusive)</div>
<div class="line">      useWebAssembly: false             // default value is false, see WebAssembly section for details</div>
<div class="line">    }</div>
<div class="line">  );</div>
</div><!-- fragment --><p>BitBucketSize 'packed' options is available since HdrHistogramJS v1.2 . Like the Java packed implementation, it has a very low memory footprint but it is way slower than regular bucket based implementation.</p>
<h2><a class="anchor" id="autotoc_md8605"></a>
Record values and retrieve metrics</h2>
<p>Once you have an histogram instance, in order to record a value you just need to call method recordValue() as below:</p>
<div class="fragment"><div class="line">import * as hdr from &quot;hdr-histogram-js&quot;</div>
<div class="line">const histogram = hdr.build();</div>
<div class="line">...</div>
<div class="line">const latency = 1234;</div>
<div class="line">histogram.recordValue(latency);</div>
</div><!-- fragment --><p>The number passed as a parameter is expected to be an integer. If it is not the case, the decimal part will be ignored.</p>
<p>Once you have recorded some values, you can get min, max, median values and of course percentiles values as shown below:</p>
<div class="fragment"><div class="line">import * as hdr from &quot;hdr-histogram-js&quot;</div>
<div class="line"> </div>
<div class="line">const h = hdr.build();</div>
<div class="line">h.recordValue(123);</div>
<div class="line">h.recordValue(122);</div>
<div class="line">h.recordValue(1244);</div>
<div class="line"> </div>
<div class="line">console.log(h.minNonZeroValue);           // 122</div>
<div class="line">console.log(h.maxValue);                  // 1244</div>
<div class="line">console.log(h.mean);                      // 486.333...</div>
<div class="line">console.log(h.getValueAtPercentile(90));  // 1244 as well</div>
<div class="line">console.log(h.summary);                   // { &quot;p50&quot;: 123, ... , max: 1244, totalCount: 3 }</div>
</div><!-- fragment --><p>If youn need a live example you can also take alook at this <a href="https://hdrhistogram.github.io/HdrHistogramJSDemo/ping-demo.html">simple ping demo</a> or this <a href="https://hdrhistogram.github.io/HdrHistogramJSDemo/hdr-on-hdr.html">HdrHistogramJS on HdrHistogramJS demo</a>.</p>
<p>You can also very easily generate a textual representation of an histogram:</p>
<div class="fragment"><div class="line">console.log(`Statistics ${h}`);</div>
<div class="line"> </div>
<div class="line">// output will be:</div>
<div class="line">//</div>
<div class="line">// Statistics Histogram 32b {</div>
<div class="line">//  &quot;p50&quot;: 123,</div>
<div class="line">//  &quot;p75&quot;: 1240,</div>
<div class="line">//  &quot;p90&quot;: 1240,</div>
<div class="line">//  &quot;p97_5&quot;: 1240,</div>
<div class="line">//  &quot;p99&quot;: 1240,</div>
<div class="line">//  &quot;p99_9&quot;: 1240,</div>
<div class="line">//  &quot;p99_99&quot;: 1240,</div>
<div class="line">//  &quot;p99_999&quot;: 1240,</div>
<div class="line">//  &quot;max&quot;: 1244,</div>
<div class="line">//  &quot;totalCount&quot;: 3</div>
<div class="line">// }</div>
</div><!-- fragment --><p>You can also general an exhaustive textual representation similar to the one generated by the original Java HdrHistogram implementation:</p>
<div class="fragment"><div class="line">import * as hdr from &quot;hdr-histogram-js&quot;</div>
<div class="line"> </div>
<div class="line">const histogram = hdr.build();</div>
<div class="line">histogram.recordValue(25);</div>
<div class="line">histogram.recordValue(50);</div>
<div class="line">histogram.recordValue(75);</div>
<div class="line">const output = histogram.outputPercentileDistribution();</div>
<div class="line"> </div>
<div class="line">// output will be:</div>
<div class="line">//</div>
<div class="line">//       Value     Percentile TotalCount 1/(1-Percentile)</div>
<div class="line">//</div>
<div class="line">//      25.000 0.000000000000          1           1.00</div>
<div class="line">//  ...</div>
<div class="line">//      75.000 0.700000000000          3           3.33</div>
<div class="line">//      75.000 1.000000000000          3</div>
<div class="line">//#[Mean    =       50.000, StdDeviation   =       20.412]</div>
<div class="line">//#[Max     =       75.000, Total count    =            3]</div>
<div class="line">//#[Buckets =           43, SubBuckets     =         2048]</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md8606"></a>
Dealing with coordinated omissions</h2>
<p>If you are recording values at a fixed rate, you can correct coordinated omissions while recording values:</p>
<div class="fragment"><div class="line">histogram.recordValueWithExpectedInterval(1234, 100);</div>
</div><!-- fragment --><p>If you prefer to apply correction afterward:</p>
<div class="fragment"><div class="line">const correctedHistogram</div>
<div class="line">  = histogram.copyCorrectedForCoordinatedOmission(100);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md8607"></a>
Boosting performances with WebAssembly</h2>
<p>Since version 2, HdrHistogramJS leverages on WebAssembly to speed up computations. Depending on the use case, the performance boost can be as high as twice as fast :) <br  />
 Everything has been done to make your life easier when using HdrHistogramJS WebAssembly implementation, but since the usage a little bit different WebAssembly is not enabled by default. <br  />
 To benefit from WebAssembly performance boost, there are three things to take care of:</p>
<ul>
<li>Bootstrap the HdrHistogramJS WebAssembly module at application startup</li>
<li>Build a WebAssembly histogram setting the useWebAssembly flag to true</li>
<li>Explicitely ask to free up memory by calling <em>histogram.destroy()</em> once an histogram is not needed anymore.</li>
</ul>
<p>Even if under the cover a WebAssembly histogram is very different from a regular JS based histogram, both provide exactly the same interface. <br  />
 The code fragment below shows how to instantiate a resizable 32 bits WebAssembly histogram:</p>
<div class="fragment"><div class="line">import * as hdr from &quot;hdr-histogram-js&quot;</div>
<div class="line"> </div>
<div class="line">// If you are on the browser side, you need to</div>
<div class="line">// load asynchronously HdrHistogramJS WASM module</div>
<div class="line">await hdr.initWebAssembly();</div>
<div class="line"> </div>
<div class="line">// If you are on the server side, you can</div>
<div class="line">// load synchronously HdrHistogramJS WASM module</div>
<div class="line">hdr.initWebAssemblySync();</div>
<div class="line"> </div>
<div class="line">const histogram = hdr.build({ useWebAssembly: true });</div>
<div class="line"> </div>
<div class="line">// you can now use your histogram the same way you would do</div>
<div class="line">// with a regular &quot;JS histogram&quot;</div>
<div class="line">histogram.recordValue(42);</div>
<div class="line">console.log(histogram.outputPercentileDistribution());</div>
<div class="line"> </div>
<div class="line">// free up memory once the histogram is not needed anymore,</div>
<div class="line">// otherwise WebAssembly memory footprint will keep growing</div>
<div class="line">// each time an histogram is created</div>
<div class="line">histogram.destroy();</div>
</div><!-- fragment --><p>Note: If you want to use this feature on the browser side, along with the UMD package, you need to add external dependency "pako". "pako" is mandatory to bootstrap the WASM module which is compressed to save some weight.</p>
<h2><a class="anchor" id="autotoc_md8608"></a>
Encode &amp; decode</h2>
<p>You can encode and decode base64 compressed histograms. Hence you can decode base64 compressed histograms produced by other implementations of HdrHistogram (Java, C#, Rust, ...). <br  />
 The code fragment below shows how to encode an histogram:</p>
<div class="fragment"><div class="line">import * as hdr from &quot;hdr-histogram-js&quot;</div>
<div class="line"> </div>
<div class="line">const histogram = hdr.build();</div>
<div class="line">histogram.recordvalue(42);</div>
<div class="line">const encodedString = hdr.encodeIntoCompressedBase64(histogram);</div>
<div class="line">// gives something that looks like &quot;HISTFAAAAB542pNpmSzMwMDAxAABzFCaEUoz2X+AMIKZAEARAtM=&quot;</div>
</div><!-- fragment --><p>Then to decode an histogram you can use this chunk of code:</p>
<div class="fragment"><div class="line">import * as hdr from &quot;hdr-histogram-js&quot;</div>
<div class="line"> </div>
<div class="line">const encodedString = &quot;HISTFAAAAB542pNpmSzMwMDAxAABzFCaEUoz2X+AMIKZAEARAtM=&quot;;</div>
<div class="line">const histogram = hdr.decodeFromCompressedBase64(encodedString);</div>
</div><!-- fragment --><p>In the above code fragment, 'histogram' is a regular 32b bucket histogram. Other types of histograms can be specified using additionnal parameters. Below a code fragment where a WebAssembly packed histogram is used:</p>
<div class="fragment"><div class="line">import * as hdr from &quot;hdr-histogram-js&quot;</div>
<div class="line"> </div>
<div class="line">const encodedString = &quot;HISTFAAAAB542pNpmSzMwMDAxAABzFCaEUoz2X+AMIKZAEARAtM=&quot;;</div>
<div class="line">const histogram = hdr.decodeFromCompressedBase64(encodedString, &#39;packed&#39;, true);</div>
</div><!-- fragment --><p>If you want to use this feature along with the UMD package, you need to add external dependency "pako". "pako" is used for zlib compression. Using npm you should get it as a transitive dependency, otherwise you need to add it in your html page.</p>
<p>You can check out <a href="https://hdrhistogram.github.io/HdrHistogramJSDemo/decoding-demo.html">this demo</a> or this <a href="https://hdrhistogram.github.io/HdrHistogramJSDemo/plotFiles.html">plotter on steroid</a> to see this feature live! <br  />
 <em>Be aware that only latest V2 encoding has been implemented, please raise a github issue if you need to see other versions implemented</em></p>
<h2><a class="anchor" id="autotoc_md8609"></a>
Histogram logs</h2>
<p>HistogramLogWriter and HistogramLogReader classes have been migrated and the API is quite similar to the one you might have used with the Java version. Below a simple usage example of the HistogramLogWriter, where the log contents are appended to a string variable:</p>
<div class="fragment"><div class="line">import * as hdr from &quot;hdr-histogram-js&quot;</div>
<div class="line"> </div>
<div class="line">let buffer: string;</div>
<div class="line">const writer = new hdr.HistogramLogWriter(content =&gt; {</div>
<div class="line">  buffer += content;</div>
<div class="line">});</div>
<div class="line">const histogram = hdr.build();</div>
<div class="line">histogram.startTimeStampMsec = 1234001;</div>
<div class="line">histogram.endTimeStampMsec   = 1235123;</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">histogram.recordValue(123000);</div>
<div class="line"> </div>
<div class="line">writer.outputLogFormatVersion();</div>
<div class="line">writer.outputLegend();</div>
<div class="line">writer.outputIntervalHistogram(histogram);</div>
</div><!-- fragment --><p>As for the reading part, if you know a little bit the Java version, the following code fragment will sound familiar:</p>
<div class="fragment"><div class="line">const reader = new hdr.HistogramLogReader(fileContent);</div>
<div class="line">let histogram;</div>
<div class="line">while ((histogram = reader.nextIntervalHistogram()) != null) {</div>
<div class="line">  // iterate on all histogram log lines</div>
<div class="line">  ...</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md8610"></a>
Performance tips</h1>
<p>HdrHistogramJS stores values in memory buckets. Memory footprint of an histogram heavily depends on 3 things:</p>
<ul>
<li>the bucket size. A bucket can take 8, 16, 32 or 64 bits of memory. 32 bits buckets is the default.</li>
<li>the precision of the histogram (i.e. the number of significant value digits). You can have up to 5 value digits, 3 value digits (default) should be enough for most use cases.</li>
<li>the allowed range of values. You can tunned this range with constructor/builder parameters <em>lowestDiscernibleValue</em> and <em>highestTrackableValue</em>. If you are not sure of these values, the best option is to use flag <em>autoResize</em>, set to true by default.</li>
</ul>
<p>While tunning memory footprint, <em>estimatedFootprintInBytes</em> histogram property can get quite useful since it gives you a clear indicator of the memory cost:</p>
<div class="fragment"><div class="line">const histogram = hdr.build();</div>
<div class="line">console.log(histogram.estimatedFootprintInBytes);</div>
</div><!-- fragment --><p>If in your context saving memory is more important than saving CPU cycles, 'packed' bucket size is highly recommended. Available since HdrHistogramJS v1.2.0, this mode enables a very effective memory compression algorithm:</p>
<div class="fragment"><div class="line">const histogram = hdr.build({ bitBucketSize: &quot;packed&quot; });</div>
<div class="line">console.log(histogram.estimatedFootprintInBytes);</div>
</div><!-- fragment --><p>Last but not least, unless you are targetting very old browsers or a very old NodeJS version, you should turn on WebAssembly mode. Available since HdrHistogramJS v2.0.0, this mode is often twice as fast as regular JS mode. Also all bucket size options are available with WebAssembly, including 'packed':</p>
<div class="fragment"><div class="line">const histogram = hdr.build({ bitBucketSize: &quot;packed&quot;, useWebAssembly: true });</div>
<div class="line">console.log(histogram.estimatedFootprintInBytes);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md8611"></a>
Tree Shaking</h1>
<p>The above examples use a convenient 'barrel' index file. Using this barrel, you cannot leverage on the tree shaking features of your favorite bundler. Hence the size of your JavaScript bundle may increase significantly. If you need to optimize the size of your bundle, you can import HdrHistogram modules as shown in code fragment below:</p>
<div class="fragment"><div class="line">import Int32Histogram from &quot;hdr-histogram-js/dist/Int32Histogram&quot;</div>
<div class="line"> </div>
<div class="line">const histogram = new Int32Histogram(1, 2, 3);</div>
<div class="line">histogram.autoResize = true;</div>
<div class="line"> </div>
<div class="line">histogram.recordValue(...);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md8612"></a>
Migrating from v1 to v2</h1>
<p>For most users, migration from HdrHistogramJS v1 to v2 should be smooth. However since HdrHistogramJS v2 does not stick anymore with HdrHistogram Java API, you might run into some breaking changes. <br  />
 Prior to v2, <em>hdr.build()</em> was returning an <em>AbstractHistogram</em> instance. <em>AbstractHistogram</em> does not exist anymore and has been replaced by the <em>Histogram</em> interface. Most methods from <em>AbstractHistogram</em> still exist in new interface <em>Histogram</em>, however in order to have a more JS idiomatic API, getter methods such as <em>getMean()</em> or <em>getTotalCount()</em> have been replaced by JS properties:</p>
<div class="fragment"><div class="line">// HdrHistogramJS v1</div>
<div class="line">const histogram: AbstractHistogram = hdr.build();</div>
<div class="line">const statistics = {</div>
<div class="line">  count: histogram.getTotalCount(),</div>
<div class="line">  mean: histogram.getMean(),</div>
<div class="line">  p99: histogram.getValueAtPercentile(99),</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// becomes with HdrHistogramJS v2</div>
<div class="line">const histogram: Histogram = hdr.build();</div>
<div class="line">const statistics = {</div>
<div class="line">  count: histogram.totalCount,</div>
<div class="line">  mean: histogram.mean,</div>
<div class="line">  p99: histogram.getValueAtPercentile(99),</div>
<div class="line">}</div>
</div><!-- fragment --><p>Module paths also change a little bit with v2. Hence if you were importing specific modules as described in the tree shaking section, you need to change a little bit your code as below:</p>
<div class="fragment"><div class="line">// HdrHistogramJS v1</div>
<div class="line">import AbstractHistogram from &quot;hdr-histogram-js/AbstractHistogram&quot;</div>
<div class="line">import Int32Histogram from &quot;hdr-histogram-js/Int32Histogram&quot;</div>
<div class="line"> </div>
<div class="line">// becomes with HdrHistogramJS v2</div>
<div class="line">import Histogram from &quot;hdr-histogram-js/dist/Histogram&quot;</div>
<div class="line">import Int32Histogram from &quot;hdr-histogram-js/dist/Int32Histogram&quot;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md8613"></a>
Design &amp; Limitations</h1>
<p>The code is almost a direct port of the Java version. Optimisation based on inheritance to avoid false sharing might not be relevant in JS, but I believe that keeping the same code structure might be handy to keep the code up to date with the Java version in the future.</p>
<p>Main limitations comes from number support in JavaScript. There is no such thing as 64b integers in JavaScript. Everything is "number", and a number is safe as an integer up to 2^53. <br  />
 The most annoying issue encountered during the code migration, is that bit operations, heavily used within original HdrHistogram, only work on the first 32 bits. That means that the following JavaScript expression is evaluated as true:</p>
<div class="fragment"><div class="line">Math.pow(2, 31) &lt;&lt; 1 === 0   // sad but true</div>
</div><!-- fragment --><p>Anyway bit shift operations are not really optimized in most browser, so... everything related to bits have been converted to good old arithmetic expressions in the process of converting the Java code to TypeScript. <br  />
 With WebAssembly and AssemblyScript things are different. HdrHistogramsJS AssemblyScript source code is closer to the original Java code since all the limitations mentioned above does not apply to WebAssembly :) </p>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_2819f17ffd536c76baa6d22c695599c9.html">GIT</a></li><li class="navelem"><a class="el" href="dir_7c2f69865df6d9deb87b81146fc3b4f6.html">FoodLink</a></li><li class="navelem"><a class="el" href="dir_060908b24f206e0870efcd71814665ad.html">foodlink.client</a></li><li class="navelem"><a class="el" href="dir_083bb234fa234c64f25ac45abfe72fc3.html">node_modules</a></li><li class="navelem"><a class="el" href="dir_abab422251f0a2e39b09d8b80b824d14.html">hdr-histogram-js</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
