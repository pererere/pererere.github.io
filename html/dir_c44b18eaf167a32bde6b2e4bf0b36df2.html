<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FoodLink: D:/GIT/FoodLink/foodlink.client/node_modules/piscina Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">FoodLink
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dir_c44b18eaf167a32bde6b2e4bf0b36df2.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">piscina Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>![Piscina Logo](<a href="https://avatars1.githubusercontent.com/u/65627548?s=200&v=4">https://avatars1.githubusercontent.com/u/65627548?s=200&amp;v=4</a>)</p>
<h1><a class="anchor" id="autotoc_md16238"></a>
piscina - the node.js worker pool</h1>
<p><img src="https://github.com/jasnell/piscina/workflows/CI/badge.svg" alt="CI" style="pointer-events: none;" class="inline"/></p>
<ul>
<li>✔ Fast communication between threads</li>
<li>✔ Covers both fixed-task and variable-task scenarios</li>
<li>✔ Supports flexible pool sizes</li>
<li>✔ Proper async tracking integration</li>
<li>✔ Tracking statistics for run and wait times</li>
<li>✔ Cancellation Support</li>
<li>✔ Supports enforcing memory resource limits</li>
<li>✔ Supports CommonJS, ESM, and TypeScript</li>
<li>✔ Custom task queues</li>
<li>✔ Optional CPU scheduling priorities on Linux</li>
</ul>
<p>Written in TypeScript.</p>
<p>For Node.js 16.x and higher.</p>
<p>MIT Licensed.</p>
<h2><a class="anchor" id="autotoc_md16239"></a>
Piscina API</h2>
<h3><a class="anchor" id="autotoc_md16240"></a>
Example</h3>
<p>In <code>main.js</code>:</p>
<div class="fragment"><div class="line">const path = require(&#39;path&#39;);</div>
<div class="line">const Piscina = require(&#39;piscina&#39;);</div>
<div class="line"> </div>
<div class="line">const piscina = new Piscina({</div>
<div class="line">  filename: path.resolve(__dirname, &#39;worker.js&#39;)</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">(async function() {</div>
<div class="line">  const result = await piscina.run({ a: 4, b: 6 });</div>
<div class="line">  console.log(result);  // Prints 10</div>
<div class="line">})();</div>
</div><!-- fragment --><p>In <code>worker.js</code>:</p>
<div class="fragment"><div class="line">module.exports = ({ a, b }) =&gt; {</div>
<div class="line">  return a + b;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The worker may also be an async function or may return a Promise:</p>
<div class="fragment"><div class="line">const { setTimeout } = require(&#39;timers/promises&#39;);</div>
<div class="line"> </div>
<div class="line">module.exports = async ({ a, b }) =&gt; {</div>
<div class="line">  // Fake some async activity</div>
<div class="line">  await setTimeout(100);</div>
<div class="line">  return a + b;</div>
<div class="line">};</div>
</div><!-- fragment --><p>ESM is also supported for both Piscina and workers:</p>
<div class="fragment"><div class="line">import { Piscina } from &#39;piscina&#39;;</div>
<div class="line"> </div>
<div class="line">const piscina = new Piscina({</div>
<div class="line">  // The URL must be a file:// URL</div>
<div class="line">  filename: new URL(&#39;./worker.mjs&#39;, import.meta.url).href</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">const result = await piscina.run({ a: 4, b: 6 });</div>
<div class="line">console.log(result); // Prints 10</div>
</div><!-- fragment --><p>In <code>worker.mjs</code>:</p>
<div class="fragment"><div class="line">export default ({ a, b }) =&gt; {</div>
<div class="line">  return a + b;</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md16241"></a>
Exporting multiple worker functions</h3>
<p>A single worker file may export multiple named handler functions.</p>
<div class="fragment"><div class="line">&#39;use strict&#39;;</div>
<div class="line"> </div>
<div class="line">function add({ a, b }) { return a + b; }</div>
<div class="line"> </div>
<div class="line">function multiply({ a, b }) { return a * b; }</div>
<div class="line"> </div>
<div class="line">add.add = add;</div>
<div class="line">add.multiply = multiply;</div>
<div class="line"> </div>
<div class="line">module.exports = add;</div>
</div><!-- fragment --><p>The export to target can then be specified when the task is submitted:</p>
<div class="fragment"><div class="line">&#39;use strict&#39;;</div>
<div class="line"> </div>
<div class="line">const Piscina = require(&#39;piscina&#39;);</div>
<div class="line">const { resolve } = require(&#39;path&#39;);</div>
<div class="line"> </div>
<div class="line">const piscina = new Piscina({</div>
<div class="line">  filename: resolve(__dirname, &#39;worker.js&#39;)</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">(async function() {</div>
<div class="line">  const res = await Promise.all([</div>
<div class="line">    piscina.run({ a: 4, b: 6 }, { name: &#39;add&#39; }),</div>
<div class="line">    piscina.run({ a: 4, b: 6 }, { name: &#39;multiply&#39; })</div>
<div class="line">  ]);</div>
<div class="line">})();</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md16242"></a>
Cancelable Tasks</h3>
<p>Submitted tasks may be canceled using either an <code>AbortController</code> or an <code>EventEmitter</code>:</p>
<div class="fragment"><div class="line">&#39;use strict&#39;;</div>
<div class="line"> </div>
<div class="line">const Piscina = require(&#39;piscina&#39;);</div>
<div class="line">const { AbortController } = require(&#39;abort-controller&#39;);</div>
<div class="line">const { resolve } = require(&#39;path&#39;);</div>
<div class="line"> </div>
<div class="line">const piscina = new Piscina({</div>
<div class="line">  filename: resolve(__dirname, &#39;worker.js&#39;)</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">(async function() {</div>
<div class="line">  const abortController = new AbortController();</div>
<div class="line">  try {</div>
<div class="line">    const { signal } = abortController;</div>
<div class="line">    const task = piscina.run({ a: 4, b: 6 }, { signal });</div>
<div class="line">    abortController.abort();</div>
<div class="line">    await task;</div>
<div class="line">  } catch (err) {</div>
<div class="line">    console.log(&#39;The task was canceled&#39;);</div>
<div class="line">  }</div>
<div class="line">})();</div>
</div><!-- fragment --><p>To use <code>AbortController</code>, you will need to <code>npm i abort-controller</code> (or <code>yarn add abort-controller</code>).</p>
<p>(In Node.js 15.0.0 or higher, there is a new built-in <code>AbortController</code> implementation that can be used here as well.)</p>
<p>Alternatively, any <code>EventEmitter</code> that emits an &lsquo;'abort&rsquo;` event may be used as an abort controller:</p>
<div class="fragment"><div class="line">&#39;use strict&#39;;</div>
<div class="line"> </div>
<div class="line">const Piscina = require(&#39;piscina&#39;);</div>
<div class="line">const EventEmitter = require(&#39;events&#39;);</div>
<div class="line">const { resolve } = require(&#39;path&#39;);</div>
<div class="line"> </div>
<div class="line">const piscina = new Piscina({</div>
<div class="line">  filename: resolve(__dirname, &#39;worker.js&#39;)</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">(async function() {</div>
<div class="line">  const ee = new EventEmitter();</div>
<div class="line">  try {</div>
<div class="line">    const task = piscina.run({ a: 4, b: 6 }, { signal: ee });</div>
<div class="line">    ee.emit(&#39;abort&#39;);</div>
<div class="line">    await task;</div>
<div class="line">  } catch (err) {</div>
<div class="line">    console.log(&#39;The task was canceled&#39;);</div>
<div class="line">  }</div>
<div class="line">})();</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md16243"></a>
Delaying Availability of Workers</h3>
<p>A worker thread will not be made available to process tasks until Piscina determines that it is "ready". By default, a worker is ready as soon as Piscina loads it and acquires a reference to the exported handler function.</p>
<p>There may be times when the availability of a worker may need to be delayed longer while the worker initializes any resources it may need to operate. To support this case, the worker module may export a <code>Promise</code> that resolves the handler function as opposed to exporting the function directly:</p>
<div class="fragment"><div class="line">async function initialize() {</div>
<div class="line">  await someAsyncInitializationActivity();</div>
<div class="line">  return ({ a, b }) =&gt; a + b;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">module.exports = initialize();</div>
</div><!-- fragment --><p>Piscina will await the resolution of the exported Promise before marking the worker thread available.</p>
<h3><a class="anchor" id="autotoc_md16244"></a>
Backpressure</h3>
<p>When the <code>maxQueue</code> option is set, once the <code>Piscina</code> queue is full, no additional tasks may be submitted until the queue size falls below the limit. The &lsquo;'drain&rsquo;` event may be used to receive notification when the queue is empty and all tasks have been submitted to workers for processing.</p>
<p>Example: Using a Node.js stream to feed a Piscina worker pool:</p>
<div class="fragment"><div class="line">&#39;use strict&#39;;</div>
<div class="line"> </div>
<div class="line">const { resolve } = require(&#39;path&#39;);</div>
<div class="line">const Pool = require(&#39;../..&#39;);</div>
<div class="line"> </div>
<div class="line">const pool = new Pool({</div>
<div class="line">  filename: resolve(__dirname, &#39;worker.js&#39;),</div>
<div class="line">  maxQueue: &#39;auto&#39;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">const stream = getStreamSomehow();</div>
<div class="line">stream.setEncoding(&#39;utf8&#39;);</div>
<div class="line"> </div>
<div class="line">pool.on(&#39;drain&#39;, () =&gt; {</div>
<div class="line">  if (stream.isPaused()) {</div>
<div class="line">    console.log(&#39;resuming...&#39;, counter, pool.queueSize);</div>
<div class="line">    stream.resume();</div>
<div class="line">  }</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">stream</div>
<div class="line">  .on(&#39;data&#39;, (data) =&gt; {</div>
<div class="line">    pool.run(data);</div>
<div class="line">    if (pool.queueSize === pool.options.maxQueue) {</div>
<div class="line">      console.log(&#39;pausing...&#39;, counter, pool.queueSize);</div>
<div class="line">      stream.pause();</div>
<div class="line">    }</div>
<div class="line">  })</div>
<div class="line">  .on(&#39;error&#39;, console.error)</div>
<div class="line">  .on(&#39;end&#39;, () =&gt; {</div>
<div class="line">    console.log(&#39;done&#39;);</div>
<div class="line">  });</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md16245"></a>
Out of scope asynchronous code</h3>
<p>A worker thread is <b>only</b> active until the moment it returns a result, it can be a result of a synchronous call or a Promise that will be fulfilled/rejected in the future. Once this is done, Piscina will wait for stdout and stderr to be flushed, and then pause the worker's event-loop until the next call. If async code is scheduled without being awaited before returning since Piscina has no way of detecting this, that code execution will be resumed on the next call. Thus, it is highly recommended to properly handle all async tasks before returning a result as it could make your code unpredictable.</p>
<p>For example:</p>
<div class="fragment"><div class="line">const { setTimeout } = require(&#39;timers/promises&#39;);</div>
<div class="line"> </div>
<div class="line">module.exports = ({ a, b }) =&gt; {</div>
<div class="line">  // This promise should be awaited</div>
<div class="line">  setTimeout(1000).then(() =&gt; {</div>
<div class="line">    console.log(&#39;Working&#39;); // This will **not** run during the same worker call</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  return a + b;</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md16246"></a>
Additional Examples</h3>
<p>Additional examples can be found in the GitHub repo at <a href="https://github.com/piscinajs/piscina/tree/master/examples">https://github.com/piscinajs/piscina/tree/master/examples</a></p>
<h2><a class="anchor" id="autotoc_md16247"></a>
Class: <code>Piscina</code></h2>
<p>Piscina works by creating a pool of Node.js Worker Threads to which one or more tasks may be dispatched. Each worker thread executes a single exported function defined in a separate file. Whenever a task is dispatched to a worker, the worker invokes the exported function and reports the return value back to Piscina when the function completes.</p>
<p>This class extends <a href="https://nodejs.org/api/events.html"><code>EventEmitter</code></a> from Node.js.</p>
<h3><a class="anchor" id="autotoc_md16248"></a>
Constructor: <code>new Piscina([options])</code></h3>
<ul>
<li>The following optional configuration is supported:<ul>
<li><code>filename</code>: (<code>string | null</code>) Provides the default source for the code that runs the tasks on Worker threads. This should be an absolute path or an absolute <code><a href="file://">file://</a></code> URL to a file that exports a JavaScript <code>function</code> or <code>async function</code> as its default export or <code>module.exports</code>. <a href="https://nodejs.org/api/esm.html">ES modules</a> are supported.</li>
<li><code>name</code>: (<code>string | null</code>) Provides the name of the default exported worker function. The default is &lsquo;'default&rsquo;<code>, indicating the default export of the worker module. *</code>minThreads<code>: (</code>number<code>) Sets the minimum number of threads that are always running for this thread pool. The default is based on the number of available CPUs. *</code>maxThreads<code>: (</code>number<code>) Sets the maximum number of threads that are running for this thread pool. The default is based on the number of available CPUs. *</code>idleTimeout<code>: (</code>number<code>) A timeout in milliseconds that specifies how long a</code>Worker<code>is allowed to be idle, i.e. not handling any tasks, before it is shut down. By default, this is immediate. **Tip**: *The default</code>idleTimeout<code> can lead to some performance loss in the application because of the overhead involved with stopping and starting new worker threads. To improve performance, try setting the</code>idleTimeout<code>explicitly.* *</code>maxQueue<code>: (</code>number<code>|</code>string<code>) The maximum number of tasks that may be scheduled to run, but not yet running due to lack of available threads, at a given time. By default, there is no limit. The special value</code>'auto'<code> may be used to have Piscina calculate the maximum as the square of</code>maxThreads<code>. When</code>'auto'<code>is used, the calculated</code>maxQueue<code>value may be found by checking the [</code>options.maxQueue<code>](#property-options-readonly) property. *</code>concurrentTasksPerWorker<code>: (</code>number<code>) Specifies how many tasks can share a single Worker thread simultaneously. The default is</code>1<code>. This generally only makes sense to specify if there is some kind of asynchronous component to the task. Keep in mind that Worker threads are generally not built for handling I/O in parallel. *</code>useAtomics<code>: (</code>boolean<code>) Use the [</code>Atomics<code>][] API for faster communication between threads. This is on by default. You can disable</code>Atomics<code>globally by setting the environment variable</code>PISCINA_DISABLE_ATOMICS<code>to</code>1<code>. If</code>useAtomics<code>is</code>true<code>, it will cause to pause threads (stoping all execution) between tasks. Ideally, threads should wait for all operations to finish before returning control to the main thread (avoid having open handles within a thread). *</code>resourceLimits<code>: (</code>object<code>) See [Node.js new Worker options][] *</code>maxOldGenerationSizeMb<code>: (</code>number<code>) The maximum size of each worker threads main heap in MB. *</code>maxYoungGenerationSizeMb<code>: (</code>number<code>) The maximum size of a heap space for recently created objects. *</code>codeRangeSizeMb<code>: (</code>number<code>) The size of a pre-allocated memory range used for generated code. *</code>stackSizeMb<code>: (</code>number<code>) The default maximum stack size for the thread. Small values may lead to unusable Worker instances. Default: 4 *</code>env<code>: (</code>object<code>) If set, specifies the initial value of</code>process.env<code>inside the worker threads. See [Node.js new Worker options][] for details. *</code>argv<code>: (</code>any[]<code>) List of arguments that will be stringified and appended to </code>process.argv<code>in the worker. See [Node.js new Worker options][] for details. *</code>execArgv<code>: (</code>string[]<code>) List of Node.js CLI options passed to the worker. See [Node.js new Worker options][] for details. *</code>workerData<code>: (</code>any<code>) Any JavaScript value that can be cloned and made available as</code>require('piscina').workerData<code>. See [Node.js new Worker options][] for details. Unlike regular Node.js Worker Threads,</code>workerData<code>must not specify any value requiring a</code>transferList<code>. This is because the</code>workerData<code> will be cloned for each pooled worker. *</code>taskQueue<code>: (</code>TaskQueue<code>) By default, Piscina uses a first-in-first-out queue for submitted tasks. The</code>taskQueue<code>option can be used to provide an alternative implementation. See [Custom Task Queues][] for additional detail. *</code>niceIncrement<code>: (</code>number<code>) An optional value that decreases priority for the individual threads, i.e. the higher the value, the lower the priority of the Worker threads. This value is only used on Linux and requires the optional [</code>nice-napi<code>][] module to be installed. See [</code>nice(2)<code>][] for more details. *</code>trackUnmanagedFds<code>: (</code>boolean<code>) An optional setting that, when</code>true<code>, will cause Workers to track file descriptors managed using</code>fs.open()<code>and </code>fs.close()<code>, and will close them automatically when the Worker exits. Defaults to</code>true`. (This option is only supported on Node.js 12.19+ and all Node.js versions higher than 14.6.0).</li>
</ul>
</li>
</ul>
<p>Use caution when setting resource limits. Setting limits that are too low may result in the <code>Piscina</code> worker threads being unusable.</p>
<h3><a class="anchor" id="autotoc_md16249"></a>
Method: <code>run(task[, options])</code></h3>
<p>Schedules a task to be run on a Worker thread.</p>
<ul>
<li><code>task</code>: Any value. This will be passed to the function that is exported from <code>filename</code>.</li>
<li><code>options</code>:<ul>
<li><code>transferList</code>: An optional lists of objects that is passed to [<code>postMessage()</code>] when posting <code>task</code> to the Worker, which are transferred rather than cloned.</li>
<li><code>filename</code>: Optionally overrides the <code>filename</code> option passed to the constructor for this task. If no <code>filename</code> was specified to the constructor, this is mandatory.</li>
<li><code>name</code>: Optionally overrides the exported worker function used for the task.</li>
<li><code>abortSignal</code>: An [<code>AbortSignal</code>][] instance. If passed, this can be used to cancel a task. If the task is already running, the corresponding <code>Worker</code> thread will be stopped. (More generally, any <code>EventEmitter</code> or <code>EventTarget</code> that emits &lsquo;'abort&rsquo;<code> events can be passed here.) Abortable tasks cannot share threads regardless of the</code>concurrentTasksPerWorker` options.</li>
</ul>
</li>
</ul>
<p>This returns a <code>Promise</code> for the return value of the (async) function call made to the function exported from <code>filename</code>. If the (async) function throws an error, the returned <code>Promise</code> will be rejected with that error. If the task is aborted, the returned <code>Promise</code> is rejected with an error as well.</p>
<h3><a class="anchor" id="autotoc_md16250"></a>
Method: <code>runTask(task[, transferList][, filename][, abortSignal])</code></h3>
<p><b>Deprecated</b> &ndash; Use <code>run(task, options)</code> instead.</p>
<p>Schedules a task to be run on a Worker thread.</p>
<ul>
<li><code>task</code>: Any value. This will be passed to the function that is exported from <code>filename</code>.</li>
<li><code>transferList</code>: An optional lists of objects that is passed to [<code>postMessage()</code>] when posting <code>task</code> to the Worker, which are transferred rather than cloned.</li>
<li><code>filename</code>: Optionally overrides the <code>filename</code> option passed to the constructor for this task. If no <code>filename</code> was specified to the constructor, this is mandatory.</li>
<li><code>abortSignal</code>: An [<code>AbortSignal</code>][] instance. If passed, this can be used to cancel a task. If the task is already running, the corresponding <code>Worker</code> thread will be stopped. (More generally, any <code>EventEmitter</code> or <code>EventTarget</code> that emits &lsquo;'abort&rsquo;<code> events can be passed here.) Abortable tasks cannot share threads regardless of the</code>concurrentTasksPerWorker` options.</li>
</ul>
<p>This returns a <code>Promise</code> for the return value of the (async) function call made to the function exported from <code>filename</code>. If the (async) function throws an error, the returned <code>Promise</code> will be rejected with that error. If the task is aborted, the returned <code>Promise</code> is rejected with an error as well.</p>
<h3><a class="anchor" id="autotoc_md16251"></a>
Method: <code>destroy()</code></h3>
<p>Stops all Workers and rejects all <code>Promise</code>s for pending tasks.</p>
<p>This returns a <code>Promise</code> that is fulfilled once all threads have stopped.</p>
<h3><a class="anchor" id="autotoc_md16252"></a>
Event: &lsquo;'error&rsquo;`</h3>
<p>An &lsquo;'error&rsquo;` event is emitted by instances of this class when:</p>
<ul>
<li>Uncaught exceptions occur inside Worker threads that do not currently handle tasks.</li>
<li>Unexpected messages are sent from from Worker threads.</li>
</ul>
<p>All other errors are reported by rejecting the <code>Promise</code> returned from <code>run()</code> or <code>runTask()</code>, including rejections reported by the handler function itself.</p>
<h3><a class="anchor" id="autotoc_md16253"></a>
Event: &lsquo;'drain&rsquo;`</h3>
<p>A &lsquo;'drain&rsquo;<code>event is emitted whenever the</code>queueSize<code>reaches</code>0`.</p>
<h3><a class="anchor" id="autotoc_md16254"></a>
Event: &lsquo;'needsDrain&rsquo;`</h3>
<p>Similar to `Piscina#needsDrain`; this event is triggered once the total capacity of the pool is exceeded by number of tasks enequeued that are pending of execution.</p>
<h3><a class="anchor" id="autotoc_md16255"></a>
Event: &lsquo;'message&rsquo;`</h3>
<p>A &lsquo;'message&rsquo;` event is emitted whenever a message is received from a worker thread.</p>
<h3><a class="anchor" id="autotoc_md16256"></a>
Property: <code>completed</code> (readonly)</h3>
<p>The current number of completed tasks.</p>
<h3><a class="anchor" id="autotoc_md16257"></a>
Property: <code>duration</code> (readonly)</h3>
<p>The length of time (in milliseconds) since this <code>Piscina</code> instance was created.</p>
<h3><a class="anchor" id="autotoc_md16258"></a>
Property: <code>options</code> (readonly)</h3>
<p>A copy of the options that are currently being used by this instance. This object has the same properties as the options object passed to the constructor.</p>
<h3><a class="anchor" id="autotoc_md16259"></a>
Property: <code>runTime</code> (readonly)</h3>
<p>A histogram summary object summarizing the collected run times of completed tasks. All values are expressed in milliseconds.</p>
<ul>
<li><code>runTime.average</code> {<code>number</code>} The average run time of all tasks</li>
<li><code>runTime.mean</code> {<code>number</code>} The mean run time of all tasks</li>
<li><code>runTime.stddev</code> {<code>number</code>} The standard deviation of collected run times</li>
<li><code>runTime.min</code> {<code>number</code>} The fastest recorded run time</li>
<li><code>runTime.max</code> {<code>number</code>} The slowest recorded run time</li>
</ul>
<p>All properties following the pattern <code>p{N}</code> where N is a number (e.g. <code>p1</code>, <code>p99</code>) represent the percentile distributions of run time observations. For example, <code>p99</code> is the 99th percentile indicating that 99% of the observed run times were faster or equal to the given value.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  average: 1880.25,</div>
<div class="line">  mean: 1880.25,</div>
<div class="line">  stddev: 1.93,</div>
<div class="line">  min: 1877,</div>
<div class="line">  max: 1882.0190887451172,</div>
<div class="line">  p0_001: 1877,</div>
<div class="line">  p0_01: 1877,</div>
<div class="line">  p0_1: 1877,</div>
<div class="line">  p1: 1877,</div>
<div class="line">  p2_5: 1877,</div>
<div class="line">  p10: 1877,</div>
<div class="line">  p25: 1877,</div>
<div class="line">  p50: 1881,</div>
<div class="line">  p75: 1881,</div>
<div class="line">  p90: 1882,</div>
<div class="line">  p97_5: 1882,</div>
<div class="line">  p99: 1882,</div>
<div class="line">  p99_9: 1882,</div>
<div class="line">  p99_99: 1882,</div>
<div class="line">  p99_999: 1882</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md16260"></a>
Property: <code>threads</code> (readonly)</h3>
<p>An Array of the <code>Worker</code> instances used by this pool.</p>
<h3><a class="anchor" id="autotoc_md16261"></a>
Property: <code>queueSize</code> (readonly)</h3>
<p>The current number of tasks waiting to be assigned to a Worker thread.</p>
<h3><a class="anchor" id="autotoc_md16262"></a>
Property: <code>needsDrain</code> (readonly)</h3>
<p>Boolean value that specifies whether the capacity of the pool has been exceeded by the number of tasks submitted.</p>
<p>This property is helpful to make decisions towards creating backpressure over the number of tasks submitted to the pool.</p>
<h3><a class="anchor" id="autotoc_md16263"></a>
Property: <code>utilization</code> (readonly)</h3>
<p>A point-in-time ratio comparing the approximate total mean run time of completed tasks to the total runtime capacity of the pool.</p>
<p>A pools runtime capacity is determined by multiplying the <code>duration</code> by the <code>options.maxThread</code> count. This provides an absolute theoretical maximum aggregate compute time that the pool would be capable of.</p>
<p>The approximate total mean run time is determined by multiplying the mean run time of all completed tasks by the total number of completed tasks. This number represents the approximate amount of time the pool as been actively processing tasks.</p>
<p>The utilization is then calculated by dividing the approximate total mean run time by the capacity, yielding a fraction between <code>0</code> and <code>1</code>.</p>
<h3><a class="anchor" id="autotoc_md16264"></a>
Property: <code>waitTime</code> (readonly)</h3>
<p>A histogram summary object summarizing the collected times tasks spent waiting in the queue. All values are expressed in milliseconds.</p>
<ul>
<li><code>waitTime.average</code> {<code>number</code>} The average wait time of all tasks</li>
<li><code>waitTime.mean</code> {<code>number</code>} The mean wait time of all tasks</li>
<li><code>waitTime.stddev</code> {<code>number</code>} The standard deviation of collected wait times</li>
<li><code>waitTime.min</code> {<code>number</code>} The fastest recorded wait time</li>
<li><code>waitTime.max</code> {<code>number</code>} The longest recorded wait time</li>
</ul>
<p>All properties following the pattern <code>p{N}</code> where N is a number (e.g. <code>p1</code>, <code>p99</code>) represent the percentile distributions of wait time observations. For example, <code>p99</code> is the 99th percentile indicating that 99% of the observed wait times were faster or equal to the given value.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  average: 1880.25,</div>
<div class="line">  mean: 1880.25,</div>
<div class="line">  stddev: 1.93,</div>
<div class="line">  min: 1877,</div>
<div class="line">  max: 1882.0190887451172,</div>
<div class="line">  p0_001: 1877,</div>
<div class="line">  p0_01: 1877,</div>
<div class="line">  p0_1: 1877,</div>
<div class="line">  p1: 1877,</div>
<div class="line">  p2_5: 1877,</div>
<div class="line">  p10: 1877,</div>
<div class="line">  p25: 1877,</div>
<div class="line">  p50: 1881,</div>
<div class="line">  p75: 1881,</div>
<div class="line">  p90: 1882,</div>
<div class="line">  p97_5: 1882,</div>
<div class="line">  p99: 1882,</div>
<div class="line">  p99_9: 1882,</div>
<div class="line">  p99_99: 1882,</div>
<div class="line">  p99_999: 1882</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md16265"></a>
Static property: <code>isWorkerThread</code> (readonly)</h3>
<p>Is <code>true</code> if this code runs inside a <code>Piscina</code> threadpool as a Worker.</p>
<h3><a class="anchor" id="autotoc_md16266"></a>
Static property: <code>version</code> (readonly)</h3>
<p>Provides the current version of this library as a semver string.</p>
<h3><a class="anchor" id="autotoc_md16267"></a>
Static method: <code>move(value)</code></h3>
<p>By default, any value returned by a worker function will be cloned when returned back to the Piscina pool, even if that object is capable of being transfered. The <code>Piscina.move()</code> method can be used to wrap and mark transferable values such that they will by transfered rather than cloned.</p>
<p>The <code>value</code> may be any object supported by Node.js to be transferable (e.g. <code>ArrayBuffer</code>, any <code>TypedArray</code>, or <code>MessagePort</code>), or any object implementing the <code>Transferable</code> interface.</p>
<div class="fragment"><div class="line">const { move } = require(&#39;piscina&#39;);</div>
<div class="line"> </div>
<div class="line">module.exports = () =&gt; {</div>
<div class="line">  return move(new ArrayBuffer(10));</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>move()</code> method will throw if the <code>value</code> is not transferable.</p>
<p>The object returned by the <code>move()</code> method should not be set as a nested value in an object. If it is used, the <code>move()</code> object itself will be cloned as opposed to transfering the object it wraps.</p>
<h4><a class="anchor" id="autotoc_md16268"></a>
Interface: <code>Transferable</code></h4>
<p>Objects may implement the <code>Transferable</code> interface to create their own custom transferable objects. This is useful when an object being passed into or from a worker contains a deeply nested transferable object such as an <code>ArrayBuffer</code> or <code>MessagePort</code>.</p>
<p><code>Transferable</code> objects expose two properties inspected by Piscina to determine how to transfer the object. These properties are named using the special static <code>Piscina.transferableSymbol</code> and <code>Piscina.valueSymbol</code> properties:</p>
<ul>
<li>The <code>Piscina.transferableSymbol</code> property provides the object (or objects) that are to be included in the <code>transferList</code>.</li>
<li>The <code>Piscina.valueSymbol</code> property provides a surrogate value to transmit in place of the <code>Transferable</code> itself.</li>
</ul>
<p>Both properties are required.</p>
<p>For example,</p>
<div class="fragment"><div class="line">const {</div>
<div class="line">  move,</div>
<div class="line">  transferableSymbol,</div>
<div class="line">  valueSymbol</div>
<div class="line">} = require(&#39;piscina&#39;);</div>
<div class="line"> </div>
<div class="line">module.exports = () =&gt; {</div>
<div class="line">  const obj = {</div>
<div class="line">    a: { b: new Uint8Array(5); },</div>
<div class="line">    c: { new Uint8Array(10); },</div>
<div class="line"> </div>
<div class="line">    get [transferableSymbol]() {</div>
<div class="line">      // Transfer the two underlying ArrayBuffers</div>
<div class="line">      return [this.a.b.buffer, this.c.buffer];</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    get [valueSymbol]() {</div>
<div class="line">      return { a: { b: this.a.b }, c: this.c };</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">  return move(obj);</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md16269"></a>
Custom Task Queues</h2>
<p>By default, Piscina uses a simple array-based first-in-first-out (fifo) task queue. When a new task is submitted and there are no available workers, tasks are pushed on to the queue until a worker becomes available.</p>
<p>If the default fifo queue is not sufficient, user code may replace the task queue implementation with a custom implementation using the <code>taskQueue</code> option on the Piscina constructor.</p>
<p>Custom task queue objects <em>must</em> implement the <code>TaskQueue</code> interface, described below using TypeScript syntax:</p>
<div class="fragment"><div class="line">interface Task {</div>
<div class="line">  readonly [Piscina.queueOptionsSymbol] : object | null;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">interface TaskQueue {</div>
<div class="line">  readonly size : number;</div>
<div class="line">  shift () : Task | null;</div>
<div class="line">  remove (task : Task) : void;</div>
<div class="line">  push (task : Task) : void;</div>
<div class="line">}</div>
</div><!-- fragment --><p>An example of a custom task queue that uses a shuffled priority queue is available in <a href="./examples/task-queue/index.js"><code>examples/task-queue</code></a>;</p>
<p>The special symbol <code>Piscina.queueOptionsSymbol</code> may be set as a property on tasks submitted to <code>run()</code> or <code>runTask()</code> as a way of passing additional options on to the custom <code>TaskQueue</code> implementation. (Note that because the queue options are set as a property on the task, tasks with queue options cannot be submitted as JavaScript primitives).</p>
<h2><a class="anchor" id="autotoc_md16270"></a>
Current Limitations (Things we're working on / would love help with)</h2>
<ul>
<li>Improved Documentation</li>
<li>Benchmarks</li>
</ul>
<h2><a class="anchor" id="autotoc_md16271"></a>
Performance Notes</h2>
<p>Workers are generally optimized for offloading synchronous, compute-intensive operations off the main Node.js event loop thread. While it is possible to perform asynchronous operations and I/O within a Worker, the performance advantages of doing so will be minimal.</p>
<p>Specifically, it is worth noting that asynchronous operations within Node.js, including I/O such as file system operations or CPU-bound tasks such as crypto operations or compression algorithms, are already performed in parallel by Node.js and libuv on a per-process level. This means that there will be little performance impact on moving such async operations into a Piscina worker (see examples/scrypt for example).</p>
<h3><a class="anchor" id="autotoc_md16272"></a>
Queue Size</h3>
<p>Piscina provides the ability to configure the minimum and maximum number of worker threads active in the pool, as well as set limits on the number of tasks that may be queued up waiting for a free worker. It is important to note that setting the <code>maxQueue</code> size too high relative to the number of worker threads can have a detrimental impact on performance and memory usage. Setting the <code>maxQueue</code> size too small can also be problematic as doing so could cause your worker threads to become idle and be shutdown. Our testing has shown that a <code>maxQueue</code> size of approximately the square of the maximum number of threads is generally sufficient and performs well for many cases, but this will vary significantly depending on your workload. It will be important to test and benchmark your worker pools to ensure you've effectively balanced queue wait times, memory usage, and worker pool utilization.</p>
<h3><a class="anchor" id="autotoc_md16273"></a>
Queue Pressure and Idle Threads</h3>
<p>The thread pool maintained by Piscina has both a minimum and maximum limit to the number of threads that may be created. When a Piscina instance is created, it will spawn the minimum number of threads immediately, then create additional threads as needed up to the limit set by <code>maxThreads</code>. Whenever a worker completes a task, a check is made to determine if there is additional work for it to perform. If there is no additional work, the thread is marked idle. By default, idle threads are shutdown immediately, with Piscina ensuring that the pool always maintains at least the minimum.</p>
<p>When a Piscina pool is processing a stream of tasks (for instance, processing http server requests as in the React server-side rendering example in examples/react-ssr), if the rate in which new tasks are received and queued is not sufficient to keep workers from going idle and terminating, the pool can experience a thrashing effect &ndash; excessively creating and terminating workers that will cause a net performance loss. There are a couple of strategies to avoid this churn:</p>
<p>Strategy 1: Ensure that the queue rate of new tasks is sufficient to keep workers from going idle. We refer to this as "queue pressure". If the queue pressure is too low, workers will go idle and terminate. If the queue pressure is too high, tasks will stack up, experience increased wait latency, and consume additional memory.</p>
<p>Strategy 2: Increase the <code>idleTimeout</code> configuration option. By default, idle threads terminate immediately. The <code>idleTimeout</code> option can be used to specify a longer period of time to wait for additional tasks to be submitted before terminating the worker. If the queue pressure is not maintained, this could result in workers sitting idle but those will have less of a performance impact than the thrashing that occurs when threads are repeatedly terminated and recreated.</p>
<p>Strategy 3: Increase the <code>minThreads</code> configuration option. This has the same basic effect as increasing the <code>idleTimeout</code>. If the queue pressure is not high enough, workers may sit idle indefinitely but there will be less of a performance hit.</p>
<p>In applications using Piscina, it will be most effective to use a combination of these three approaches and tune the various configuration parameters to find the optimum combination both for the application workload and the capabilities of the deployment environment. There are no one set of options that are going to work best.</p>
<h3><a class="anchor" id="autotoc_md16274"></a>
Thread priority on Linux systems</h3>
<p>On Linux systems that support <a href="https://linux.die.net/man/2/nice"><code>nice(2)</code></a>, Piscina is capable of setting the priority of every worker in the pool. To use this mechanism, an additional optional native addon dependency (<code>nice-napi</code>, <code>npm i nice-napi</code>) is required. Once <a href="https://npmjs.org/package/nice-napi"><code>nice-napi</code></a> is installed, creating a <code>Piscina</code> instance with the <code>niceIncrement</code> configuration option will set the priority for the pool:</p>
<div class="fragment"><div class="line">const Piscina = require(&#39;piscina&#39;);</div>
<div class="line">const pool = new Piscina({</div>
<div class="line">  worker: &#39;/absolute/path/to/worker.js&#39;,</div>
<div class="line">  niceIncrement: 20</div>
<div class="line">});</div>
</div><!-- fragment --><p>The higher the <code>niceIncrement</code>, the lower the CPU scheduling priority will be for the pooled workers which will generally extend the execution time of CPU-bound tasks but will help prevent those threads from stealing CPU time from the main Node.js event loop thread. Whether this is a good thing or not depends entirely on your application and will require careful profiling to get correct.</p>
<p>The key metrics to pay attention to when tuning the <code>niceIncrement</code> are the sampled run times of the tasks in the worker pool (using the `runTime` property) and the <a href="https://nodejs.org/dist/latest-v14.x/docs/api/perf_hooks.html#perf_hooks_perf_hooks_monitoreventloopdelay_options">delay of the Node.js main thread event loop</a>.</p>
<h3><a class="anchor" id="autotoc_md16275"></a>
Multiple Thread Pools and Embedding Piscina as a Dependency</h3>
<p>Every <code>Piscina</code> instance creates a separate pool of threads and operates without any awareness of the other. When multiple pools are created in a single application the various threads may contend with one another, and with the Node.js main event loop thread, and may cause an overall reduction in system performance.</p>
<p>Modules that embed Piscina as a dependency <em>should</em> make it clear via documentation that threads are being used. It would be ideal if those would make it possible for users to provide an existing <code>Piscina</code> instance as a configuration option in lieu of always creating their own.</p>
<h2><a class="anchor" id="autotoc_md16276"></a>
Release Notes</h2>
<h3><a class="anchor" id="autotoc_md16277"></a>
4.1.0</h3>
<h4><a class="anchor" id="autotoc_md16278"></a>
Features</h4>
<ul>
<li>add <code>needsDrain</code> property (<a href="https://github.com/piscinajs/piscina/issues/368">#368</a>) (<a href="https://github.com/piscinajs/piscina/commit/2d49b63368116c172a52e2019648049b4d280162">2d49b63</a>)</li>
<li>correctly handle process.exit calls outside of a task (<a href="https://github.com/piscinajs/piscina/issues/361">#361</a>) (<a href="https://github.com/piscinajs/piscina/commit/8e6d16e1dc23f8bb39772ed954f6689852ad435f">8e6d16e</a>)</li>
</ul>
<h4><a class="anchor" id="autotoc_md16279"></a>
Bug Fixes</h4>
<ul>
<li>Fix types for TypeScript 4.7 (<a href="https://github.com/piscinajs/piscina/issues/239">#239</a>) (<a href="https://github.com/piscinajs/piscina/commit/a38fb292e8fcc45cc20abab8668f82d908a24dc0">a38fb29</a>)</li>
<li>use CJS imports (<a href="https://github.com/piscinajs/piscina/issues/374">#374</a>) (<a href="https://github.com/piscinajs/piscina/commit/edf8dc4f1a19e9b49e266109cdb70d9acc86f3ca">edf8dc4</a>)</li>
</ul>
<h3><a class="anchor" id="autotoc_md16280"></a>
4.0.0</h3>
<ul>
<li>Drop Node.js 14.x support</li>
<li>Add Node.js 20.x to CI</li>
</ul>
<h3><a class="anchor" id="autotoc_md16281"></a>
3.2.0</h3>
<ul>
<li>Adds a new <code>PISCINA_DISABLE_ATOMICS</code> environment variable as an alternative way of disabling Piscina's internal use of the <code>Atomics</code> API. (<a href="https://github.com/piscinajs/piscina/pull/163">https://github.com/piscinajs/piscina/pull/163</a>)</li>
<li>Fixes a bug with transferable objects. (<a href="https://github.com/piscinajs/piscina/pull/155">https://github.com/piscinajs/piscina/pull/155</a>)</li>
<li>Fixes CI issues with TypeScript. (<a href="https://github.com/piscinajs/piscina/pull/161">https://github.com/piscinajs/piscina/pull/161</a>)</li>
</ul>
<h3><a class="anchor" id="autotoc_md16282"></a>
3.1.0</h3>
<ul>
<li>Deprecates <code>piscina.runTask()</code>; adds <code>piscina.run()</code> as an alternative. <a href="https://github.com/piscinajs/piscina/commit/d7fa24d7515789001f7237ad6ae9ad42d582fc75">https://github.com/piscinajs/piscina/commit/d7fa24d7515789001f7237ad6ae9ad42d582fc75</a></li>
<li>Allows multiple exported handler functions from a single file. <a href="https://github.com/piscinajs/piscina/commit/d7fa24d7515789001f7237ad6ae9ad42d582fc75">https://github.com/piscinajs/piscina/commit/d7fa24d7515789001f7237ad6ae9ad42d582fc75</a></li>
</ul>
<h3><a class="anchor" id="autotoc_md16283"></a>
3.0.0</h3>
<ul>
<li>Drops Node.js 10.x support</li>
<li>Updates minimum TypeScript target to ES2019</li>
</ul>
<h3><a class="anchor" id="autotoc_md16284"></a>
2.1.0</h3>
<ul>
<li>Adds name property to indicate <code>AbortError</code> when tasks are canceled using an <code>AbortController</code> (or similar)</li>
<li>More examples</li>
</ul>
<h3><a class="anchor" id="autotoc_md16285"></a>
2.0.0</h3>
<ul>
<li>Added unmanaged file descriptor tracking</li>
<li>Updated dependencies</li>
</ul>
<h3><a class="anchor" id="autotoc_md16286"></a>
1.6.1</h3>
<ul>
<li>Bug fix: Reject if AbortSignal is already aborted</li>
<li>Bug Fix: Use once listener for abort event</li>
</ul>
<h3><a class="anchor" id="autotoc_md16287"></a>
1.6.0</h3>
<ul>
<li>Add the <code>niceIncrement</code> configuration parameter.</li>
</ul>
<h3><a class="anchor" id="autotoc_md16288"></a>
1.5.1</h3>
<ul>
<li>Bug fixes around abortable task selection.</li>
</ul>
<h3><a class="anchor" id="autotoc_md16289"></a>
1.5.0</h3>
<ul>
<li>Added <code>Piscina.move()</code></li>
<li>Added Custom Task Queues</li>
<li>Added utilization metric</li>
<li>Wait for workers to be ready before considering them as candidates</li>
<li>Additional examples</li>
</ul>
<h3><a class="anchor" id="autotoc_md16290"></a>
1.4.0</h3>
<ul>
<li>Added &lsquo;maxQueue = 'auto&rsquo;` to autocalculate the maximum queue size.</li>
<li>Added more examples, including an example of implementing a worker as a Node.js native addon.</li>
</ul>
<h3><a class="anchor" id="autotoc_md16291"></a>
1.3.0</h3>
<ul>
<li>Added the &lsquo;'drain&rsquo;` event</li>
</ul>
<h3><a class="anchor" id="autotoc_md16292"></a>
1.2.0</h3>
<ul>
<li>Added support for ESM and <a href="file://">file://</a> URLs</li>
<li>Added <code>env</code>, <code>argv</code>, <code>execArgv</code>, and <code>workerData</code> options</li>
<li>More examples</li>
</ul>
<h3><a class="anchor" id="autotoc_md16293"></a>
1.1.0</h3>
<ul>
<li>Added support for Worker Thread <code>resourceLimits</code></li>
</ul>
<h3><a class="anchor" id="autotoc_md16294"></a>
1.0.0</h3>
<ul>
<li>Initial release!</li>
</ul>
<h2><a class="anchor" id="autotoc_md16295"></a>
The Team</h2>
<ul>
<li>James M Snell <a href="#" onclick="location.href='mai'+'lto:'+'jas'+'ne'+'ll@'+'gm'+'ail'+'.c'+'om'; return false;">jasne<span class="obfuscator">.nosp@m.</span>ll@g<span class="obfuscator">.nosp@m.</span>mail.<span class="obfuscator">.nosp@m.</span>com</a></li>
<li>Anna Henningsen <a href="#" onclick="location.href='mai'+'lto:'+'ann'+'a@'+'add'+'al'+'eax'+'.n'+'et'; return false;">anna@<span class="obfuscator">.nosp@m.</span>adda<span class="obfuscator">.nosp@m.</span>leax.<span class="obfuscator">.nosp@m.</span>net</a></li>
<li>Matteo Collina <a href="#" onclick="location.href='mai'+'lto:'+'mat'+'te'+'o.c'+'ol'+'lin'+'a@'+'gma'+'il'+'.co'+'m'; return false;">matte<span class="obfuscator">.nosp@m.</span>o.co<span class="obfuscator">.nosp@m.</span>llina<span class="obfuscator">.nosp@m.</span>@gma<span class="obfuscator">.nosp@m.</span>il.co<span class="obfuscator">.nosp@m.</span>m</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md16296"></a>
Acknowledgements</h2>
<p>Piscina development is sponsored by <a href="https://www.nearform.com/research/">NearForm Research</a>. </p>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_2819f17ffd536c76baa6d22c695599c9.html">GIT</a></li><li class="navelem"><a class="el" href="dir_7c2f69865df6d9deb87b81146fc3b4f6.html">FoodLink</a></li><li class="navelem"><a class="el" href="dir_060908b24f206e0870efcd71814665ad.html">foodlink.client</a></li><li class="navelem"><a class="el" href="dir_083bb234fa234c64f25ac45abfe72fc3.html">node_modules</a></li><li class="navelem"><a class="el" href="dir_c44b18eaf167a32bde6b2e4bf0b36df2.html">piscina</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
