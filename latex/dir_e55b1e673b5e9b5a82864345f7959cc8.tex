\doxysection{D\+:/\+GIT/\+Food\+Link/foodlink.client/node\+\_\+modules/cacache/node\+\_\+modules/lru-\/cache Directory Reference}
\hypertarget{dir_e55b1e673b5e9b5a82864345f7959cc8}{}\label{dir_e55b1e673b5e9b5a82864345f7959cc8}\index{D:/GIT/FoodLink/foodlink.client/node\_modules/cacache/node\_modules/lru-\/cache Directory Reference@{D:/GIT/FoodLink/foodlink.client/node\_modules/cacache/node\_modules/lru-\/cache Directory Reference}}


\doxysubsection{Detailed Description}
A cache object that deletes the least-\/recently-\/used items.

Specify a max number of the most recently used items that you want to keep, and this cache will keep that many of the most recently accessed items.

This is not primarily a TTL cache, and does not make strong TTL guarantees. There is no preemptive pruning of expired items by default, but you {\itshape may} set a TTL on the cache or on a single {\ttfamily set}. If you do so, it will treat expired items as missing, and delete them when fetched. If you are more interested in TTL caching than LRU caching, check out \href{http://npm.im/@isaacs/ttlcache}{\texttt{ @isaacs/ttlcache}}.

As of version 7, this is one of the most performant LRU implementations available in Java\+Script, and supports a wide diversity of use cases. However, note that using some of the features will necessarily impact performance, by causing the cache to have to do more work. See the "{}\+Performance"{} section below.\hypertarget{README.md_autotoc_md3693}{}\doxysubsection{\texorpdfstring{Installation}{Installation}}\label{README.md_autotoc_md3693}

\begin{DoxyCode}{0}
\DoxyCodeLine{npm\ install\ lru-\/cache\ -\/-\/save}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3694}{}\doxysubsection{\texorpdfstring{Usage}{Usage}}\label{README.md_autotoc_md3694}

\begin{DoxyCode}{0}
\DoxyCodeLine{//\ hybrid\ module,\ either\ works}
\DoxyCodeLine{import\ \{\ LRUCache\ \}\ from\ 'lru-\/cache'}
\DoxyCodeLine{//\ or:}
\DoxyCodeLine{const\ \{\ LRUCache\ \}\ =\ require('lru-\/cache')}
\DoxyCodeLine{//\ or\ in\ minified\ form\ for\ web\ browsers:}
\DoxyCodeLine{import\ \{\ LRUCache\ \}\ from\ 'http://unpkg.com/lru-\/cache@9/dist/mjs/index.min.mjs'}
\DoxyCodeLine{}
\DoxyCodeLine{//\ At\ least\ one\ of\ 'max',\ 'ttl',\ or\ 'maxSize'\ is\ required,\ to\ prevent}
\DoxyCodeLine{//\ unsafe\ unbounded\ storage.}
\DoxyCodeLine{//}
\DoxyCodeLine{//\ In\ most\ cases,\ it's\ best\ to\ specify\ a\ max\ for\ performance,\ so\ all}
\DoxyCodeLine{//\ the\ required\ memory\ allocation\ is\ done\ up-\/front.}
\DoxyCodeLine{//}
\DoxyCodeLine{//\ All\ the\ other\ options\ are\ optional,\ see\ the\ sections\ below\ for}
\DoxyCodeLine{//\ documentation\ on\ what\ each\ one\ does.\ \ Most\ of\ them\ can\ be}
\DoxyCodeLine{//\ overridden\ for\ specific\ items\ in\ get()/set()}
\DoxyCodeLine{const\ options\ =\ \{}
\DoxyCodeLine{\ \ max:\ 500,}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ for\ use\ with\ tracking\ overall\ storage\ size}
\DoxyCodeLine{\ \ maxSize:\ 5000,}
\DoxyCodeLine{\ \ sizeCalculation:\ (value,\ key)\ =>\ \{}
\DoxyCodeLine{\ \ \ \ return\ 1}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ for\ use\ when\ you\ need\ to\ clean\ up\ something\ when\ objects}
\DoxyCodeLine{\ \ //\ are\ evicted\ from\ the\ cache}
\DoxyCodeLine{\ \ dispose:\ (value,\ key)\ =>\ \{}
\DoxyCodeLine{\ \ \ \ freeFromMemoryOrWhatever(value)}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ how\ long\ to\ live\ in\ ms}
\DoxyCodeLine{\ \ ttl:\ 1000\ *\ 60\ *\ 5,}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ return\ stale\ items\ before\ removing\ from\ cache?}
\DoxyCodeLine{\ \ allowStale:\ false,}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ updateAgeOnGet:\ false,}
\DoxyCodeLine{\ \ updateAgeOnHas:\ false,}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ async\ method\ to\ use\ for\ cache.fetch(),\ for}
\DoxyCodeLine{\ \ //\ stale-\/while-\/revalidate\ type\ of\ behavior}
\DoxyCodeLine{\ \ fetchMethod:\ async\ (}
\DoxyCodeLine{\ \ \ \ key,}
\DoxyCodeLine{\ \ \ \ staleValue,}
\DoxyCodeLine{\ \ \ \ \{\ options,\ signal,\ context\ \}}
\DoxyCodeLine{\ \ )\ =>\ \{\},}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{const\ cache\ =\ new\ LRUCache(options)}
\DoxyCodeLine{}
\DoxyCodeLine{cache.set('key',\ 'value')}
\DoxyCodeLine{cache.get('key')\ //\ "{}value"{}}
\DoxyCodeLine{}
\DoxyCodeLine{//\ non-\/string\ keys\ ARE\ fully\ supported}
\DoxyCodeLine{//\ but\ note\ that\ it\ must\ be\ THE\ SAME\ object,\ not}
\DoxyCodeLine{//\ just\ a\ JSON-\/equivalent\ object.}
\DoxyCodeLine{var\ someObject\ =\ \{\ a:\ 1\ \}}
\DoxyCodeLine{cache.set(someObject,\ 'a\ value')}
\DoxyCodeLine{//\ Object\ keys\ are\ not\ toString()-\/ed}
\DoxyCodeLine{cache.set('[object\ Object]',\ 'a\ different\ value')}
\DoxyCodeLine{assert.equal(cache.get(someObject),\ 'a\ value')}
\DoxyCodeLine{//\ A\ similar\ object\ with\ same\ keys/values\ won't\ work,}
\DoxyCodeLine{//\ because\ it's\ a\ different\ object\ identity}
\DoxyCodeLine{assert.equal(cache.get(\{\ a:\ 1\ \}),\ undefined)}
\DoxyCodeLine{}
\DoxyCodeLine{cache.clear()\ //\ empty\ the\ cache}

\end{DoxyCode}


If you put more stuff in the cache, then less recently used items will fall out. That\textquotesingle{}s what an LRU cache is.\hypertarget{README.md_autotoc_md3695}{}\doxysubsection{\texorpdfstring{{\ttfamily class LRUCache\texorpdfstring{$<$}{<}K, V, FC = unknown\texorpdfstring{$>$}{>}(options)}}{{\ttfamily class LRUCache\texorpdfstring{$<$}{<}K, V, FC = unknown\texorpdfstring{$>$}{>}(options)}}}\label{README.md_autotoc_md3695}
Create a new {\ttfamily LRUCache} object.

When using Type\+Script, set the {\ttfamily K} and {\ttfamily V} types to the {\ttfamily key} and {\ttfamily value} types, respectively.

The {\ttfamily FC} ("{}fetch context"{}) generic type defaults to {\ttfamily unknown}. If set to a value other than {\ttfamily void} or {\ttfamily undefined}, then any calls to {\ttfamily cache.\+fetch()} {\itshape must} provide a {\ttfamily context} option matching the {\ttfamily FC} type. If {\ttfamily FC} is set to {\ttfamily void} or {\ttfamily undefined}, then {\ttfamily cache.\+fetch()} {\itshape must not} provide a {\ttfamily context} option. See the documentation on {\ttfamily async fetch()} below.\hypertarget{README.md_autotoc_md3696}{}\doxysubsection{\texorpdfstring{Options}{Options}}\label{README.md_autotoc_md3696}
All options are available on the LRUCache instance, making it safe to pass an LRUCache instance as the options argument to make another empty cache of the same type.

Some options are marked read-\/only because changing them after instantiation is not safe. Changing any of the other options will of course only have an effect on subsequent method calls.\hypertarget{README.md_autotoc_md3697}{}\doxysubsubsection{\texorpdfstring{{\ttfamily max} (read only)}{{\ttfamily max} (read only)}}\label{README.md_autotoc_md3697}
The maximum number of items that remain in the cache (assuming no TTL pruning or explicit deletions). Note that fewer items may be stored if size calculation is used, and {\ttfamily max\+Size} is exceeded. This must be a positive finite intger.

At least one of {\ttfamily max}, {\ttfamily max\+Size}, or {\ttfamily TTL} is required. This must be a positive integer if set.

{\bfseries{It is strongly recommended to set a {\ttfamily max} to prevent unbounded growth of the cache.}} See "{}\+Storage Bounds Safety"{} below.\hypertarget{README.md_autotoc_md3698}{}\doxysubsubsection{\texorpdfstring{{\ttfamily max\+Size} (read only)}{{\ttfamily max\+Size} (read only)}}\label{README.md_autotoc_md3698}
Set to a positive integer to track the sizes of items added to the cache, and automatically evict items in order to stay below this size. Note that this may result in fewer than {\ttfamily max} items being stored.

Attempting to add an item to the cache whose calculated size is greater that this amount will be a no-\/op. The item will not be cached, and no other items will be evicted.

Optional, must be a positive integer if provided.

Sets {\ttfamily max\+Entry\+Size} to the same value, unless a different value is provided for {\ttfamily max\+Entry\+Size}.

At least one of {\ttfamily max}, {\ttfamily max\+Size}, or {\ttfamily TTL} is required. This must be a positive integer if set.

Even if size tracking is enabled, {\bfseries{it is strongly recommended to set a {\ttfamily max} to prevent unbounded growth of the cache.}} See "{}\+Storage Bounds Safety"{} below.\hypertarget{README.md_autotoc_md3699}{}\doxysubsubsection{\texorpdfstring{{\ttfamily max\+Entry\+Size}}{{\ttfamily max\+Entry\+Size}}}\label{README.md_autotoc_md3699}
Set to a positive integer to track the sizes of items added to the cache, and prevent caching any item over a given size. Attempting to add an item whose calculated size is greater than this amount will be a no-\/op. The item will not be cached, and no other items will be evicted.

Optional, must be a positive integer if provided. Defaults to the value of {\ttfamily max\+Size} if provided.\hypertarget{README.md_autotoc_md3700}{}\doxysubsubsection{\texorpdfstring{{\ttfamily size\+Calculation}}{{\ttfamily size\+Calculation}}}\label{README.md_autotoc_md3700}
Function used to calculate the size of stored items. If you\textquotesingle{}re storing strings or buffers, then you probably want to do something like {\ttfamily n =\texorpdfstring{$>$}{>} n.\+length}. The item is passed as the first argument, and the key is passed as the second argument.

This may be overridden by passing an options object to {\ttfamily cache.\+set()}.

Requires {\ttfamily max\+Size} to be set.

If the {\ttfamily size} (or return value of {\ttfamily size\+Calculation}) for a given entry is greater than {\ttfamily max\+Entry\+Size}, then the item will not be added to the cache.\hypertarget{README.md_autotoc_md3701}{}\doxysubsubsection{\texorpdfstring{{\ttfamily fetch\+Method} (read only)}{{\ttfamily fetch\+Method} (read only)}}\label{README.md_autotoc_md3701}
Function that is used to make background asynchronous fetches. Called with {\ttfamily fetch\+Method(key, stale\+Value, \{ signal, options, context \})}. May return a Promise.

If {\ttfamily fetch\+Method} is not provided, then {\ttfamily cache.\+fetch(key)} is equivalent to {\ttfamily Promise.\+resolve(cache.\+get(key))}.

If at any time, {\ttfamily signal.\+aborted} is set to {\ttfamily true}, or if the {\ttfamily signal.\+onabort} method is called, or if it emits an `\textquotesingle{}abort'{\ttfamily  event which you can listen to with}add\+Event\+Listener\`{}, then that means that the fetch should be abandoned. This may be passed along to async functions aware of Abort\+Controller/\+Abort\+Signal behavior.

The {\ttfamily fetch\+Method} should {\bfseries{only}} return {\ttfamily undefined} or a Promise resolving to {\ttfamily undefined} if the Abort\+Controller signaled an {\ttfamily abort} event. In all other cases, it should return or resolve to a value suitable for adding to the cache.

The {\ttfamily options} object is a union of the options that may be provided to {\ttfamily set()} and {\ttfamily get()}. If they are modified, then that will result in modifying the settings to {\ttfamily cache.\+set()} when the value is resolved, and in the case of {\ttfamily no\+Delete\+On\+Fetch\+Rejection} and {\ttfamily allow\+Stale\+On\+Fetch\+Rejection}, the handling of {\ttfamily fetch\+Method} failures.

For example, a DNS cache may update the TTL based on the value returned from a remote DNS server by changing {\ttfamily options.\+ttl} in the {\ttfamily fetch\+Method}.\hypertarget{README.md_autotoc_md3702}{}\doxysubsubsection{\texorpdfstring{{\ttfamily no\+Delete\+On\+Fetch\+Rejection}}{{\ttfamily no\+Delete\+On\+Fetch\+Rejection}}}\label{README.md_autotoc_md3702}
If a {\ttfamily fetch\+Method} throws an error or returns a rejected promise, then by default, any existing stale value will be removed from the cache.

If {\ttfamily no\+Delete\+On\+Fetch\+Rejection} is set to {\ttfamily true}, then this behavior is suppressed, and the stale value remains in the cache in the case of a rejected {\ttfamily fetch\+Method}.

This is important in cases where a {\ttfamily fetch\+Method} is {\itshape only} called as a background update while the stale value is returned, when {\ttfamily allow\+Stale} is used.

This is implicitly in effect when {\ttfamily allow\+Stale\+On\+Fetch\+Rejection} is set.

This may be set in calls to {\ttfamily fetch()}, or defaulted on the constructor, or overridden by modifying the options object in the {\ttfamily fetch\+Method}.\hypertarget{README.md_autotoc_md3703}{}\doxysubsubsection{\texorpdfstring{{\ttfamily allow\+Stale\+On\+Fetch\+Rejection}}{{\ttfamily allow\+Stale\+On\+Fetch\+Rejection}}}\label{README.md_autotoc_md3703}
Set to true to return a stale value from the cache when a {\ttfamily fetch\+Method} throws an error or returns a rejected Promise.

If a {\ttfamily fetch\+Method} fails, and there is no stale value available, the {\ttfamily fetch()} will resolve to {\ttfamily undefined}. Ie, all {\ttfamily fetch\+Method} errors are suppressed.

Implies {\ttfamily no\+Delete\+On\+Fetch\+Rejection}.

This may be set in calls to {\ttfamily fetch()}, or defaulted on the constructor, or overridden by modifying the options object in the {\ttfamily fetch\+Method}.\hypertarget{README.md_autotoc_md3704}{}\doxysubsubsection{\texorpdfstring{{\ttfamily allow\+Stale\+On\+Fetch\+Abort}}{{\ttfamily allow\+Stale\+On\+Fetch\+Abort}}}\label{README.md_autotoc_md3704}
Set to true to return a stale value from the cache when the {\ttfamily Abort\+Signal} passed to the {\ttfamily fetch\+Method} dispatches an `\textquotesingle{}abort'\`{} event, whether user-\/triggered, or due to internal cache behavior.

Unless {\ttfamily ignore\+Fetch\+Abort} is also set, the underlying {\ttfamily fetch\+Method} will still be considered canceled, and any value it returns will be ignored and not cached.

Caveat\+: since fetches are aborted when a new value is explicitly set in the cache, this can lead to fetch returning a stale value, since that was the fallback value {\itshape at the moment the {\ttfamily fetch()} was initiated}, even though the new updated value is now present in the cache.

For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ cache\ =\ new\ LRUCache<string,\ any>(\{}
\DoxyCodeLine{\ \ ttl:\ 100,}
\DoxyCodeLine{\ \ fetchMethod:\ async\ (url,\ oldValue,\ \{\ signal\ \})\ =>\ \{}
\DoxyCodeLine{\ \ \ \ const\ res\ =\ await\ fetch(url,\ \{\ signal\ \})}
\DoxyCodeLine{\ \ \ \ return\ await\ res.json()}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\})}
\DoxyCodeLine{cache.set('https://example.com/',\ \{\ some:\ 'data'\ \})}
\DoxyCodeLine{//\ 100ms\ go\ by...}
\DoxyCodeLine{const\ result\ =\ cache.fetch('https://example.com/')}
\DoxyCodeLine{cache.set('https://example.com/',\ \{\ other:\ 'thing'\ \})}
\DoxyCodeLine{console.log(await\ result)\ //\ \{\ some:\ 'data'\ \}}
\DoxyCodeLine{console.log(cache.get('https://example.com/'))\ //\ \{\ other:\ 'thing'\ \}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3705}{}\doxysubsubsection{\texorpdfstring{{\ttfamily ignore\+Fetch\+Abort}}{{\ttfamily ignore\+Fetch\+Abort}}}\label{README.md_autotoc_md3705}
Set to true to ignore the {\ttfamily abort} event emitted by the {\ttfamily Abort\+Signal} object passed to {\ttfamily fetch\+Method}, and still cache the resulting resolution value, as long as it is not {\ttfamily undefined}.

When used on its own, this means aborted {\ttfamily fetch()} calls are not immediately resolved or rejected when they are aborted, and instead take the full time to await.

When used with {\ttfamily allow\+Stale\+On\+Fetch\+Abort}, aborted {\ttfamily fetch()} calls will resolve immediately to their stale cached value or {\ttfamily undefined}, and will continue to process and eventually update the cache when they resolve, as long as the resulting value is not {\ttfamily undefined}, thus supporting a "{}return stale on timeout while refreshing"{} mechanism by passing {\ttfamily Abort\+Signal.\+timeout(n)} as the signal.

For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ c\ =\ new\ LRUCache(\{}
\DoxyCodeLine{\ \ ttl:\ 100,}
\DoxyCodeLine{\ \ ignoreFetchAbort:\ true,}
\DoxyCodeLine{\ \ allowStaleOnFetchAbort:\ true,}
\DoxyCodeLine{\ \ fetchMethod:\ async\ (key,\ oldValue,\ \{\ signal\ \})\ =>\ \{}
\DoxyCodeLine{\ \ \ \ //\ note:\ do\ NOT\ pass\ the\ signal\ to\ fetch()!}
\DoxyCodeLine{\ \ \ \ //\ let's\ say\ this\ fetch\ can\ take\ a\ long\ time.}
\DoxyCodeLine{\ \ \ \ const\ res\ =\ await\ fetch(`https://slow-\/backend-\/server/\$\{key\}`)}
\DoxyCodeLine{\ \ \ \ return\ await\ res.json()}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\})}
\DoxyCodeLine{}
\DoxyCodeLine{//\ this\ will\ return\ the\ stale\ value\ after\ 100ms,\ while\ still}
\DoxyCodeLine{//\ updating\ in\ the\ background\ for\ next\ time.}
\DoxyCodeLine{const\ val\ =\ await\ c.fetch('key',\ \{\ signal:\ AbortSignal.timeout(100)\ \})}

\end{DoxyCode}


{\bfseries{Note}}\+: regardless of this setting, an {\ttfamily abort} event {\itshape is still emitted on the {\ttfamily Abort\+Signal} object}, so may result in invalid results when passed to other underlying APIs that use Abort\+Signals.

This may be overridden on the {\ttfamily fetch()} call or in the {\ttfamily fetch\+Method} itself.\hypertarget{README.md_autotoc_md3706}{}\doxysubsubsection{\texorpdfstring{{\ttfamily dispose} (read only)}{{\ttfamily dispose} (read only)}}\label{README.md_autotoc_md3706}
Function that is called on items when they are dropped from the cache, as {\ttfamily this.\+dispose(value, key, reason)}.

This can be handy if you want to close file descriptors or do other cleanup tasks when items are no longer stored in the cache.

{\bfseries{NOTE}}\+: It is called {\itshape before} the item has been fully removed from the cache, so if you want to put it right back in, you need to wait until the next tick. If you try to add it back in during the {\ttfamily dispose()} function call, it will break things in subtle and weird ways.

Unlike several other options, this may {\itshape not} be overridden by passing an option to {\ttfamily set()}, for performance reasons.

The {\ttfamily reason} will be one of the following strings, corresponding to the reason for the item\textquotesingle{}s deletion\+:


\begin{DoxyItemize}
\item {\ttfamily evict} Item was evicted to make space for a new addition
\item {\ttfamily set} Item was overwritten by a new value
\item {\ttfamily delete} Item was removed by explicit {\ttfamily cache.\+delete(key)} or by calling {\ttfamily cache.\+clear()}, which deletes everything.
\end{DoxyItemize}

The {\ttfamily dispose()} method is {\itshape not} called for canceled calls to {\ttfamily fetch\+Method()}. If you wish to handle evictions, overwrites, and deletes of in-\/flight asynchronous fetches, you must use the {\ttfamily Abort\+Signal} provided.

Optional, must be a function.\hypertarget{README.md_autotoc_md3707}{}\doxysubsubsection{\texorpdfstring{{\ttfamily dispose\+After} (read only)}{{\ttfamily dispose\+After} (read only)}}\label{README.md_autotoc_md3707}
The same as {\ttfamily dispose}, but called {\itshape after} the entry is completely removed and the cache is once again in a clean state.

It is safe to add an item right back into the cache at this point. However, note that it is {\itshape very} easy to inadvertently create infinite recursion in this way.

The {\ttfamily dispose\+After()} method is {\itshape not} called for canceled calls to {\ttfamily fetch\+Method()}. If you wish to handle evictions, overwrites, and deletes of in-\/flight asynchronous fetches, you must use the {\ttfamily Abort\+Signal} provided.\hypertarget{README.md_autotoc_md3708}{}\doxysubsubsection{\texorpdfstring{{\ttfamily no\+Dispose\+On\+Set}}{{\ttfamily no\+Dispose\+On\+Set}}}\label{README.md_autotoc_md3708}
Set to {\ttfamily true} to suppress calling the {\ttfamily dispose()} function if the entry key is still accessible within the cache.

This may be overridden by passing an options object to {\ttfamily cache.\+set()}.

Boolean, default {\ttfamily false}. Only relevant if {\ttfamily dispose} or {\ttfamily dispose\+After} options are set.\hypertarget{README.md_autotoc_md3709}{}\doxysubsubsection{\texorpdfstring{{\ttfamily ttl}}{{\ttfamily ttl}}}\label{README.md_autotoc_md3709}
Max time to live for items before they are considered stale. Note that stale items are NOT preemptively removed by default, and MAY live in the cache, contributing to its LRU max, long after they have expired.

Also, as this cache is optimized for LRU/\+MRU operations, some of the staleness/\+TTL checks will reduce performance.

This is not primarily a TTL cache, and does not make strong TTL guarantees. There is no pre-\/emptive pruning of expired items, but you {\itshape may} set a TTL on the cache, and it will treat expired items as missing when they are fetched, and delete them.

Optional, but must be a positive integer in ms if specified.

This may be overridden by passing an options object to {\ttfamily cache.\+set()}.

At least one of {\ttfamily max}, {\ttfamily max\+Size}, or {\ttfamily TTL} is required. This must be a positive integer if set.

Even if ttl tracking is enabled, {\bfseries{it is strongly recommended to set a {\ttfamily max} to prevent unbounded growth of the cache.}} See "{}\+Storage Bounds Safety"{} below.

If ttl tracking is enabled, and {\ttfamily max} and {\ttfamily max\+Size} are not set, and {\ttfamily ttl\+Autopurge} is not set, then a warning will be emitted cautioning about the potential for unbounded memory consumption. (The Type\+Script definitions will also discourage this.)\hypertarget{README.md_autotoc_md3710}{}\doxysubsubsection{\texorpdfstring{{\ttfamily no\+Update\+TTL}}{{\ttfamily no\+Update\+TTL}}}\label{README.md_autotoc_md3710}
Boolean flag to tell the cache to not update the TTL when setting a new value for an existing key (ie, when updating a value rather than inserting a new value). Note that the TTL value is {\itshape always} set (if provided) when adding a new entry into the cache.

This may be passed as an option to {\ttfamily cache.\+set()}.

Boolean, default false.\hypertarget{README.md_autotoc_md3711}{}\doxysubsubsection{\texorpdfstring{{\ttfamily ttl\+Resolution}}{{\ttfamily ttl\+Resolution}}}\label{README.md_autotoc_md3711}
Minimum amount of time in ms in which to check for staleness. Defaults to {\ttfamily 1}, which means that the current time is checked at most once per millisecond.

Set to {\ttfamily 0} to check the current time every time staleness is tested.

Note that setting this to a higher value {\itshape will} improve performance somewhat while using ttl tracking, albeit at the expense of keeping stale items around a bit longer than intended.\hypertarget{README.md_autotoc_md3712}{}\doxysubsubsection{\texorpdfstring{{\ttfamily ttl\+Autopurge}}{{\ttfamily ttl\+Autopurge}}}\label{README.md_autotoc_md3712}
Preemptively remove stale items from the cache.

Note that this may {\itshape significantly} degrade performance, especially if the cache is storing a large number of items. It is almost always best to just leave the stale items in the cache, and let them fall out as new items are added.

Note that this means that {\ttfamily allow\+Stale} is a bit pointless, as stale items will be deleted almost as soon as they expire.

Use with caution!

Boolean, default {\ttfamily false}\hypertarget{README.md_autotoc_md3713}{}\doxysubsubsection{\texorpdfstring{{\ttfamily allow\+Stale}}{{\ttfamily allow\+Stale}}}\label{README.md_autotoc_md3713}
By default, if you set {\ttfamily ttl}, it\textquotesingle{}ll only delete stale items from the cache when you {\ttfamily get(key)}. That is, it\textquotesingle{}s not preemptively pruning items.

If you set {\ttfamily allow\+Stale\+:true}, it\textquotesingle{}ll return the stale value as well as deleting it. If you don\textquotesingle{}t set this, then it\textquotesingle{}ll return {\ttfamily undefined} when you try to get a stale entry.

Note that when a stale entry is fetched, {\itshape even if it is returned due to {\ttfamily allow\+Stale} being set}, it is removed from the cache immediately. You can immediately put it back in the cache if you wish, thus resetting the TTL.

This may be overridden by passing an options object to {\ttfamily cache.\+get()}. The {\ttfamily cache.\+has()} method will always return {\ttfamily false} for stale items.

Boolean, default false, only relevant if {\ttfamily ttl} is set.\hypertarget{README.md_autotoc_md3714}{}\doxysubsubsection{\texorpdfstring{{\ttfamily no\+Delete\+On\+Stale\+Get}}{{\ttfamily no\+Delete\+On\+Stale\+Get}}}\label{README.md_autotoc_md3714}
When using time-\/expiring entries with {\ttfamily ttl}, by default stale items will be removed from the cache when the key is accessed with {\ttfamily cache.\+get()}.

Setting {\ttfamily no\+Delete\+On\+Stale\+Get} to {\ttfamily true} will cause stale items to remain in the cache, until they are explicitly deleted with {\ttfamily cache.\+delete(key)}, or retrieved with {\ttfamily no\+Delete\+On\+Stale\+Get} set to {\ttfamily false}.

This may be overridden by passing an options object to {\ttfamily cache.\+get()}.

Boolean, default false, only relevant if {\ttfamily ttl} is set.\hypertarget{README.md_autotoc_md3715}{}\doxysubsubsection{\texorpdfstring{{\ttfamily update\+Age\+On\+Get}}{{\ttfamily update\+Age\+On\+Get}}}\label{README.md_autotoc_md3715}
When using time-\/expiring entries with {\ttfamily ttl}, setting this to {\ttfamily true} will make each item\textquotesingle{}s age reset to 0 whenever it is retrieved from cache with {\ttfamily get()}, causing it to not expire. (It can still fall out of cache based on recency of use, of course.)

This may be overridden by passing an options object to {\ttfamily cache.\+get()}.

Boolean, default false, only relevant if {\ttfamily ttl} is set.\hypertarget{README.md_autotoc_md3716}{}\doxysubsubsection{\texorpdfstring{{\ttfamily update\+Age\+On\+Has}}{{\ttfamily update\+Age\+On\+Has}}}\label{README.md_autotoc_md3716}
When using time-\/expiring entries with {\ttfamily ttl}, setting this to {\ttfamily true} will make each item\textquotesingle{}s age reset to 0 whenever its presence in the cache is checked with {\ttfamily has()}, causing it to not expire. (It can still fall out of cache based on recency of use, of course.)

This may be overridden by passing an options object to {\ttfamily cache.\+has()}.

Boolean, default false, only relevant if {\ttfamily ttl} is set.\hypertarget{README.md_autotoc_md3717}{}\doxysubsection{\texorpdfstring{API}{API}}\label{README.md_autotoc_md3717}
\hypertarget{README.md_autotoc_md3718}{}\doxysubsubsection{\texorpdfstring{{\ttfamily new LRUCache\texorpdfstring{$<$}{<}K, V, FC = unknown\texorpdfstring{$>$}{>}(options)}}{{\ttfamily new LRUCache\texorpdfstring{$<$}{<}K, V, FC = unknown\texorpdfstring{$>$}{>}(options)}}}\label{README.md_autotoc_md3718}
Create a new LRUCache. All options are documented above, and are on the cache as public members.

The {\ttfamily K} and {\ttfamily V} types define the key and value types, respectively. The optional {\ttfamily FC} type defines the type of the {\ttfamily context} object passed to {\ttfamily cache.\+fetch()}.

Keys and values {\bfseries{must not}} be {\ttfamily null} or {\ttfamily undefined}.\hypertarget{README.md_autotoc_md3719}{}\doxysubsubsection{\texorpdfstring{{\ttfamily cache.\+max}, {\ttfamily cache.\+max\+Size}, {\ttfamily cache.\+allow\+Stale},}{{\ttfamily cache.\+max}, {\ttfamily cache.\+max\+Size}, {\ttfamily cache.\+allow\+Stale},}}\label{README.md_autotoc_md3719}
{\ttfamily cache.\+no\+Dispose\+On\+Set}, {\ttfamily cache.\+size\+Calculation}, {\ttfamily cache.\+dispose}, {\ttfamily cache.\+max\+Size}, {\ttfamily cache.\+ttl}, {\ttfamily cache.\+update\+Age\+On\+Get}, {\ttfamily cache.\+update\+Age\+On\+Has}

All option names are exposed as public members on the cache object.

These are intended for read access only. Changing them during program operation can cause undefined behavior.\hypertarget{README.md_autotoc_md3720}{}\doxysubsubsection{\texorpdfstring{{\ttfamily cache.\+size}}{{\ttfamily cache.\+size}}}\label{README.md_autotoc_md3720}
The total number of items held in the cache at the current moment.\hypertarget{README.md_autotoc_md3721}{}\doxysubsubsection{\texorpdfstring{{\ttfamily cache.\+calculated\+Size}}{{\ttfamily cache.\+calculated\+Size}}}\label{README.md_autotoc_md3721}
The total size of items in cache when using size tracking.\hypertarget{README.md_autotoc_md3722}{}\doxysubsubsection{\texorpdfstring{{\ttfamily set(key, value, \mbox{[}\{ size, size\+Calculation, ttl, no\+Dispose\+On\+Set, start, status \}\mbox{]})}}{{\ttfamily set(key, value, \mbox{[}\{ size, size\+Calculation, ttl, no\+Dispose\+On\+Set, start, status \}\mbox{]})}}}\label{README.md_autotoc_md3722}
Add a value to the cache.

Optional options object may contain {\ttfamily ttl} and {\ttfamily size\+Calculation} as described above, which default to the settings on the cache object.

If {\ttfamily start} is provided, then that will set the effective start time for the TTL calculation. Note that this must be a previous value of {\ttfamily performance.\+now()} if supported, or a previous value of {\ttfamily Date.\+now()} if not.

Options object may also include {\ttfamily size}, which will prevent calling the {\ttfamily size\+Calculation} function and just use the specified number if it is a positive integer, and {\ttfamily no\+Dispose\+On\+Set} which will prevent calling a {\ttfamily dispose} function in the case of overwrites.

If the {\ttfamily size} (or return value of {\ttfamily size\+Calculation}) for a given entry is greater than {\ttfamily max\+Entry\+Size}, then the item will not be added to the cache.

Will update the recency of the entry.

Returns the cache object.

For the usage of the {\ttfamily status} option, see {\bfseries{Status Tracking}} below.

If the value is {\ttfamily undefined}, then this is an alias for {\ttfamily cache.\+delete(key)}. {\ttfamily undefined} is never stored in the cache. See {\bfseries{Storing Undefined Values}} below.\hypertarget{README.md_autotoc_md3723}{}\doxysubsubsection{\texorpdfstring{{\ttfamily get(key, \{ update\+Age\+On\+Get, allow\+Stale, status \} = \{\}) =\texorpdfstring{$>$}{>} value}}{{\ttfamily get(key, \{ update\+Age\+On\+Get, allow\+Stale, status \} = \{\}) =\texorpdfstring{$>$}{>} value}}}\label{README.md_autotoc_md3723}
Return a value from the cache.

Will update the recency of the cache entry found.

If the key is not found, {\ttfamily get()} will return {\ttfamily undefined}.

For the usage of the {\ttfamily status} option, see {\bfseries{Status Tracking}} below.\hypertarget{README.md_autotoc_md3724}{}\doxysubsubsection{\texorpdfstring{{\ttfamily info(key) =\texorpdfstring{$>$}{>} Entry \texorpdfstring{$\vert$}{|} undefined}}{{\ttfamily info(key) =\texorpdfstring{$>$}{>} Entry \texorpdfstring{$\vert$}{|} undefined}}}\label{README.md_autotoc_md3724}
Return an {\ttfamily Entry} object containing the currently cached value, as well as ttl and size information if available. Returns undefined if the key is not found in the cache.

Unlike {\ttfamily dump()} (which is designed to be portable and survive serialization), the {\ttfamily start} value is always the current timestamp, and the {\ttfamily ttl} is a calculated remaining time to live (negative if expired).

Note that stale values are always returned, rather than being pruned and treated as if they were not in the cache. If you wish to exclude stale entries, guard against a negative {\ttfamily ttl} value.\hypertarget{README.md_autotoc_md3725}{}\doxysubsubsection{\texorpdfstring{{\ttfamily async fetch(key, options = \{\}) =\texorpdfstring{$>$}{>} Promise}}{{\ttfamily async fetch(key, options = \{\}) =\texorpdfstring{$>$}{>} Promise}}}\label{README.md_autotoc_md3725}
The following options are supported\+:


\begin{DoxyItemize}
\item {\ttfamily update\+Age\+On\+Get}
\item {\ttfamily allow\+Stale}
\item {\ttfamily size}
\item {\ttfamily size\+Calculation}
\item {\ttfamily ttl}
\item {\ttfamily no\+Dispose\+On\+Set}
\item {\ttfamily force\+Refresh}
\item {\ttfamily status} -\/ See {\bfseries{Status Tracking}} below.
\item {\ttfamily signal} -\/ Abort\+Signal can be used to cancel the {\ttfamily fetch()}. Note that the {\ttfamily signal} option provided to the {\ttfamily fetch\+Method} is a different object, because it must also respond to internal cache state changes, but aborting this signal will abort the one passed to {\ttfamily fetch\+Method} as well.
\item {\ttfamily context} -\/ sets the {\ttfamily context} option passed to the underlying {\ttfamily fetch\+Method}.
\end{DoxyItemize}

If the value is in the cache and not stale, then the returned Promise resolves to the value.

If not in the cache, or beyond its TTL staleness, then {\ttfamily fetch\+Method(key, stale\+Value, \{ options, signal, context \})} is called, and the value returned will be added to the cache once resolved.

If called with {\ttfamily allow\+Stale}, and an asynchronous fetch is currently in progress to reload a stale value, then the former stale value will be returned.

If called with {\ttfamily force\+Refresh}, then the cached item will be re-\/fetched, even if it is not stale. However, if {\ttfamily allow\+Stale} is set, then the old value will still be returned. This is useful in cases where you want to force a reload of a cached value. If a background fetch is already in progress, then {\ttfamily force\+Refresh} has no effect.

Multiple fetches for the same {\ttfamily key} will only call {\ttfamily fetch\+Method} a single time, and all will be resolved when the value is resolved, even if different options are used.

If {\ttfamily fetch\+Method} is not specified, then this is effectively an alias for {\ttfamily Promise.\+resolve(cache.\+get(key))}.

When the fetch method resolves to a value, if the fetch has not been aborted due to deletion, eviction, or being overwritten, then it is added to the cache using the options provided.

If the key is evicted or deleted before the {\ttfamily fetch\+Method} resolves, then the Abort\+Signal passed to the {\ttfamily fetch\+Method} will receive an {\ttfamily abort} event, and the promise returned by {\ttfamily fetch()} will reject with the reason for the abort.

If a {\ttfamily signal} is passed to the {\ttfamily fetch()} call, then aborting the signal will abort the fetch and cause the {\ttfamily fetch()} promise to reject with the reason provided.\hypertarget{README.md_autotoc_md3726}{}\doxysubsubsubsection{\texorpdfstring{Setting {\ttfamily context}}{Setting {\ttfamily context}}}\label{README.md_autotoc_md3726}
If an {\ttfamily FC} type is set to a type other than {\ttfamily unknown}, {\ttfamily void}, or {\ttfamily undefined} in the LRUCache constructor, then all calls to {\ttfamily cache.\+fetch()} {\itshape must} provide a {\ttfamily context} option. If set to {\ttfamily undefined} or {\ttfamily void}, then calls to fetch {\itshape must not} provide a {\ttfamily context} option.

The {\ttfamily context} param allows you to provide arbitrary data that might be relevant in the course of fetching the data. It is only relevant for the course of a single {\ttfamily fetch()} operation, and discarded afterwards.\hypertarget{README.md_autotoc_md3727}{}\doxysubsubsubsection{\texorpdfstring{Note\+: {\ttfamily fetch()} calls are inflight-\/unique}{Note\+: {\ttfamily fetch()} calls are inflight-\/unique}}\label{README.md_autotoc_md3727}
If you call {\ttfamily fetch()} multiple times with the same key value, then every call after the first will resolve on the same promise\textsuperscript{1}, {\itshape even if they have different settings that would otherwise change the behvavior of the fetch}, such as {\ttfamily no\+Delete\+On\+Fetch\+Rejection} or {\ttfamily ignore\+Fetch\+Abort}.

In most cases, this is not a problem (in fact, only fetching something once is what you probably want, if you\textquotesingle{}re caching in the first place). If you are changing the fetch() options dramatically between runs, there\textquotesingle{}s a good chance that you might be trying to fit divergent semantics into a single object, and would be better off with multiple cache instances.

{\bfseries{1}}\+: Ie, they\textquotesingle{}re not the "{}same Promise"{}, but they resolve at the same time, because they\textquotesingle{}re both waiting on the same underlying fetch\+Method response.\hypertarget{README.md_autotoc_md3728}{}\doxysubsubsection{\texorpdfstring{{\ttfamily peek(key, \{ allow\+Stale \} = \{\}) =\texorpdfstring{$>$}{>} value}}{{\ttfamily peek(key, \{ allow\+Stale \} = \{\}) =\texorpdfstring{$>$}{>} value}}}\label{README.md_autotoc_md3728}
Like {\ttfamily get()} but doesn\textquotesingle{}t update recency or delete stale items.

Returns {\ttfamily undefined} if the item is stale, unless {\ttfamily allow\+Stale} is set either on the cache or in the options object.\hypertarget{README.md_autotoc_md3729}{}\doxysubsubsection{\texorpdfstring{{\ttfamily has(key, \{ update\+Age\+On\+Has, status \} = \{\}) =\texorpdfstring{$>$}{>} Boolean}}{{\ttfamily has(key, \{ update\+Age\+On\+Has, status \} = \{\}) =\texorpdfstring{$>$}{>} Boolean}}}\label{README.md_autotoc_md3729}
Check if a key is in the cache, without updating the recency of use. Age is updated if {\ttfamily update\+Age\+On\+Has} is set to {\ttfamily true} in either the options or the constructor.

Will return {\ttfamily false} if the item is stale, even though it is technically in the cache. The difference can be determined (if it matters) by using a {\ttfamily status} argument, and inspecting the {\ttfamily has} field.

For the usage of the {\ttfamily status} option, see {\bfseries{Status Tracking}} below.\hypertarget{README.md_autotoc_md3730}{}\doxysubsubsection{\texorpdfstring{{\ttfamily delete(key)}}{{\ttfamily delete(key)}}}\label{README.md_autotoc_md3730}
Deletes a key out of the cache.

Returns {\ttfamily true} if the key was deleted, {\ttfamily false} otherwise.\hypertarget{README.md_autotoc_md3731}{}\doxysubsubsection{\texorpdfstring{{\ttfamily clear()}}{{\ttfamily clear()}}}\label{README.md_autotoc_md3731}
Clear the cache entirely, throwing away all values.\hypertarget{README.md_autotoc_md3732}{}\doxysubsubsection{\texorpdfstring{{\ttfamily keys()}}{{\ttfamily keys()}}}\label{README.md_autotoc_md3732}
Return a generator yielding the keys in the cache, in order from most recently used to least recently used.\hypertarget{README.md_autotoc_md3733}{}\doxysubsubsection{\texorpdfstring{{\ttfamily rkeys()}}{{\ttfamily rkeys()}}}\label{README.md_autotoc_md3733}
Return a generator yielding the keys in the cache, in order from least recently used to most recently used.\hypertarget{README.md_autotoc_md3734}{}\doxysubsubsection{\texorpdfstring{{\ttfamily values()}}{{\ttfamily values()}}}\label{README.md_autotoc_md3734}
Return a generator yielding the values in the cache, in order from most recently used to least recently used.\hypertarget{README.md_autotoc_md3735}{}\doxysubsubsection{\texorpdfstring{{\ttfamily rvalues()}}{{\ttfamily rvalues()}}}\label{README.md_autotoc_md3735}
Return a generator yielding the values in the cache, in order from least recently used to most recently used.\hypertarget{README.md_autotoc_md3736}{}\doxysubsubsection{\texorpdfstring{{\ttfamily entries()}}{{\ttfamily entries()}}}\label{README.md_autotoc_md3736}
Return a generator yielding {\ttfamily \mbox{[}key, value\mbox{]}} pairs, in order from most recently used to least recently used.\hypertarget{README.md_autotoc_md3737}{}\doxysubsubsection{\texorpdfstring{{\ttfamily rentries()}}{{\ttfamily rentries()}}}\label{README.md_autotoc_md3737}
Return a generator yielding {\ttfamily \mbox{[}key, value\mbox{]}} pairs, in order from least recently used to most recently used.\hypertarget{README.md_autotoc_md3738}{}\doxysubsubsection{\texorpdfstring{{\ttfamily find(fn, \mbox{[}get\+Options\mbox{]})}}{{\ttfamily find(fn, \mbox{[}get\+Options\mbox{]})}}}\label{README.md_autotoc_md3738}
Find a value for which the supplied {\ttfamily fn} method returns a truthy value, similar to {\ttfamily Array.\+find()}.

{\ttfamily fn} is called as {\ttfamily fn(value, key, cache)}.

The optional {\ttfamily get\+Options} are applied to the resulting {\ttfamily get()} of the item found.\hypertarget{README.md_autotoc_md3739}{}\doxysubsubsection{\texorpdfstring{{\ttfamily dump()}}{{\ttfamily dump()}}}\label{README.md_autotoc_md3739}
Return an array of {\ttfamily \mbox{[}key, entry\mbox{]}} objects which can be passed to {\ttfamily cache.\+load()}

The {\ttfamily start} fields are calculated relative to a portable {\ttfamily Date.\+now()} timestamp, even if {\ttfamily performance.\+now()} is available.

Stale entries are always included in the {\ttfamily dump}, even if {\ttfamily allow\+Stale} is false.

Note\+: this returns an actual array, not a generator, so it can be more easily passed around.\hypertarget{README.md_autotoc_md3740}{}\doxysubsubsection{\texorpdfstring{{\ttfamily load(entries)}}{{\ttfamily load(entries)}}}\label{README.md_autotoc_md3740}
Reset the cache and load in the items in {\ttfamily entries} in the order listed. Note that the shape of the resulting cache may be different if the same options are not used in both caches.

The {\ttfamily start} fields are assumed to be calculated relative to a portable {\ttfamily Date.\+now()} timestamp, even if {\ttfamily performance.\+now()} is available.\hypertarget{README.md_autotoc_md3741}{}\doxysubsubsection{\texorpdfstring{{\ttfamily purge\+Stale()}}{{\ttfamily purge\+Stale()}}}\label{README.md_autotoc_md3741}
Delete any stale entries. Returns {\ttfamily true} if anything was removed, {\ttfamily false} otherwise.\hypertarget{README.md_autotoc_md3742}{}\doxysubsubsection{\texorpdfstring{{\ttfamily get\+Remaining\+TTL(key)}}{{\ttfamily get\+Remaining\+TTL(key)}}}\label{README.md_autotoc_md3742}
Return the number of ms left in the item\textquotesingle{}s TTL. If item is not in cache, returns {\ttfamily 0}. Returns {\ttfamily Infinity} if item is in cache without a defined TTL.\hypertarget{README.md_autotoc_md3743}{}\doxysubsubsection{\texorpdfstring{{\ttfamily for\+Each(fn, \mbox{[}thisp\mbox{]})}}{{\ttfamily for\+Each(fn, \mbox{[}thisp\mbox{]})}}}\label{README.md_autotoc_md3743}
Call the {\ttfamily fn} function with each set of {\ttfamily fn(value, key, cache)} in the LRU cache, from most recent to least recently used.

Does not affect recency of use.

If {\ttfamily thisp} is provided, function will be called in the {\ttfamily this}-\/context of the provided object.\hypertarget{README.md_autotoc_md3744}{}\doxysubsubsection{\texorpdfstring{{\ttfamily rfor\+Each(fn, \mbox{[}thisp\mbox{]})}}{{\ttfamily rfor\+Each(fn, \mbox{[}thisp\mbox{]})}}}\label{README.md_autotoc_md3744}
Same as {\ttfamily cache.\+for\+Each(fn, thisp)}, but in order from least recently used to most recently used.\hypertarget{README.md_autotoc_md3745}{}\doxysubsubsection{\texorpdfstring{{\ttfamily pop()}}{{\ttfamily pop()}}}\label{README.md_autotoc_md3745}
Evict the least recently used item, returning its value.

Returns {\ttfamily undefined} if cache is empty.\hypertarget{README.md_autotoc_md3746}{}\doxysubsection{\texorpdfstring{Status Tracking}{Status Tracking}}\label{README.md_autotoc_md3746}
Occasionally, it may be useful to track the internal behavior of the cache, particularly for logging, debugging, or for behavior within the {\ttfamily fetch\+Method}. To do this, you can pass a {\ttfamily status} object to the {\ttfamily get()}, {\ttfamily set()}, {\ttfamily has()}, and {\ttfamily fetch()} methods.

The {\ttfamily status} option should be a plain Java\+Script object.

The following fields will be set appropriately\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{interface\ Status<V>\ \{}
\DoxyCodeLine{\ \ /**}
\DoxyCodeLine{\ \ \ *\ The\ status\ of\ a\ set()\ operation.}
\DoxyCodeLine{\ \ \ *}
\DoxyCodeLine{\ \ \ *\ -\/\ add:\ the\ item\ was\ not\ found\ in\ the\ cache,\ and\ was\ added}
\DoxyCodeLine{\ \ \ *\ -\/\ update:\ the\ item\ was\ in\ the\ cache,\ with\ the\ same\ value\ provided}
\DoxyCodeLine{\ \ \ *\ -\/\ replace:\ the\ item\ was\ in\ the\ cache,\ and\ replaced}
\DoxyCodeLine{\ \ \ *\ -\/\ miss:\ the\ item\ was\ not\ added\ to\ the\ cache\ for\ some\ reason}
\DoxyCodeLine{\ \ \ */}
\DoxyCodeLine{\ \ set?:\ 'add'\ |\ 'update'\ |\ 'replace'\ |\ 'miss'}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ /**}
\DoxyCodeLine{\ \ \ *\ the\ ttl\ stored\ for\ the\ item,\ or\ undefined\ if\ ttls\ are\ not\ used.}
\DoxyCodeLine{\ \ \ */}
\DoxyCodeLine{\ \ ttl?:\ LRUMilliseconds}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ /**}
\DoxyCodeLine{\ \ \ *\ the\ start\ time\ for\ the\ item,\ or\ undefined\ if\ ttls\ are\ not\ used.}
\DoxyCodeLine{\ \ \ */}
\DoxyCodeLine{\ \ start?:\ LRUMilliseconds}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ /**}
\DoxyCodeLine{\ \ \ *\ The\ timestamp\ used\ for\ TTL\ calculation}
\DoxyCodeLine{\ \ \ */}
\DoxyCodeLine{\ \ now?:\ LRUMilliseconds}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ /**}
\DoxyCodeLine{\ \ \ *\ the\ remaining\ ttl\ for\ the\ item,\ or\ undefined\ if\ ttls\ are\ not\ used.}
\DoxyCodeLine{\ \ \ */}
\DoxyCodeLine{\ \ remainingTTL?:\ LRUMilliseconds}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ /**}
\DoxyCodeLine{\ \ \ *\ The\ calculated\ size\ for\ the\ item,\ if\ sizes\ are\ used.}
\DoxyCodeLine{\ \ \ */}
\DoxyCodeLine{\ \ size?:\ LRUSize}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ /**}
\DoxyCodeLine{\ \ \ *\ A\ flag\ indicating\ that\ the\ item\ was\ not\ stored,\ due\ to\ exceeding\ the}
\DoxyCodeLine{\ \ \ *\ \{@link\ maxEntrySize\}}
\DoxyCodeLine{\ \ \ */}
\DoxyCodeLine{\ \ maxEntrySizeExceeded?:\ true}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ /**}
\DoxyCodeLine{\ \ \ *\ The\ old\ value,\ specified\ in\ the\ case\ of\ \`{}set:'update'`\ or}
\DoxyCodeLine{\ \ \ *\ \`{}set:'replace'`}
\DoxyCodeLine{\ \ \ */}
\DoxyCodeLine{\ \ oldValue?:\ V}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ /**}
\DoxyCodeLine{\ \ \ *\ The\ results\ of\ a\ \{@link\ has\}\ operation}
\DoxyCodeLine{\ \ \ *}
\DoxyCodeLine{\ \ \ *\ -\/\ hit:\ the\ item\ was\ found\ in\ the\ cache}
\DoxyCodeLine{\ \ \ *\ -\/\ stale:\ the\ item\ was\ found\ in\ the\ cache,\ but\ is\ stale}
\DoxyCodeLine{\ \ \ *\ -\/\ miss:\ the\ item\ was\ not\ found\ in\ the\ cache}
\DoxyCodeLine{\ \ \ */}
\DoxyCodeLine{\ \ has?:\ 'hit'\ |\ 'stale'\ |\ 'miss'}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ /**}
\DoxyCodeLine{\ \ \ *\ The\ status\ of\ a\ \{@link\ fetch\}\ operation.}
\DoxyCodeLine{\ \ \ *\ Note\ that\ this\ can\ change\ as\ the\ underlying\ fetch()\ moves\ through}
\DoxyCodeLine{\ \ \ *\ various\ states.}
\DoxyCodeLine{\ \ \ *}
\DoxyCodeLine{\ \ \ *\ -\/\ inflight:\ there\ is\ another\ fetch()\ for\ this\ key\ which\ is\ in\ process}
\DoxyCodeLine{\ \ \ *\ -\/\ get:\ there\ is\ no\ fetchMethod,\ so\ \{@link\ get\}\ was\ called.}
\DoxyCodeLine{\ \ \ *\ -\/\ miss:\ the\ item\ is\ not\ in\ cache,\ and\ will\ be\ fetched.}
\DoxyCodeLine{\ \ \ *\ -\/\ hit:\ the\ item\ is\ in\ the\ cache,\ and\ was\ resolved\ immediately.}
\DoxyCodeLine{\ \ \ *\ -\/\ stale:\ the\ item\ is\ in\ the\ cache,\ but\ stale.}
\DoxyCodeLine{\ \ \ *\ -\/\ refresh:\ the\ item\ is\ in\ the\ cache,\ and\ not\ stale,\ but}
\DoxyCodeLine{\ \ \ *\ \ \ \{@link\ forceRefresh\}\ was\ specified.}
\DoxyCodeLine{\ \ \ */}
\DoxyCodeLine{\ \ fetch?:\ 'get'\ |\ 'inflight'\ |\ 'miss'\ |\ 'hit'\ |\ 'stale'\ |\ 'refresh'}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ /**}
\DoxyCodeLine{\ \ \ *\ The\ \{@link\ fetchMethod\}\ was\ called}
\DoxyCodeLine{\ \ \ */}
\DoxyCodeLine{\ \ fetchDispatched?:\ true}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ /**}
\DoxyCodeLine{\ \ \ *\ The\ cached\ value\ was\ updated\ after\ a\ successful\ call\ to\ fetchMethod}
\DoxyCodeLine{\ \ \ */}
\DoxyCodeLine{\ \ fetchUpdated?:\ true}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ /**}
\DoxyCodeLine{\ \ \ *\ The\ reason\ for\ a\ fetch()\ rejection.\ \ Either\ the\ error\ raised\ by\ the}
\DoxyCodeLine{\ \ \ *\ \{@link\ fetchMethod\},\ or\ the\ reason\ for\ an\ AbortSignal.}
\DoxyCodeLine{\ \ \ */}
\DoxyCodeLine{\ \ fetchError?:\ Error}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ /**}
\DoxyCodeLine{\ \ \ *\ The\ fetch\ received\ an\ abort\ signal}
\DoxyCodeLine{\ \ \ */}
\DoxyCodeLine{\ \ fetchAborted?:\ true}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ /**}
\DoxyCodeLine{\ \ \ *\ The\ abort\ signal\ received\ was\ ignored,\ and\ the\ fetch\ was\ allowed\ to}
\DoxyCodeLine{\ \ \ *\ continue.}
\DoxyCodeLine{\ \ \ */}
\DoxyCodeLine{\ \ fetchAbortIgnored?:\ true}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ /**}
\DoxyCodeLine{\ \ \ *\ The\ fetchMethod\ promise\ resolved\ successfully}
\DoxyCodeLine{\ \ \ */}
\DoxyCodeLine{\ \ fetchResolved?:\ true}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ /**}
\DoxyCodeLine{\ \ \ *\ The\ results\ of\ the\ fetchMethod\ promise\ were\ stored\ in\ the\ cache}
\DoxyCodeLine{\ \ \ */}
\DoxyCodeLine{\ \ fetchUpdated?:\ true}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ /**}
\DoxyCodeLine{\ \ \ *\ The\ fetchMethod\ promise\ was\ rejected}
\DoxyCodeLine{\ \ \ */}
\DoxyCodeLine{\ \ fetchRejected?:\ true}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ /**}
\DoxyCodeLine{\ \ \ *\ The\ status\ of\ a\ \{@link\ get\}\ operation.}
\DoxyCodeLine{\ \ \ *}
\DoxyCodeLine{\ \ \ *\ -\/\ fetching:\ The\ item\ is\ currently\ being\ fetched.\ \ If\ a\ previous\ value\ is}
\DoxyCodeLine{\ \ \ *\ \ \ present\ and\ allowed,\ that\ will\ be\ returned.}
\DoxyCodeLine{\ \ \ *\ -\/\ stale:\ The\ item\ is\ in\ the\ cache,\ and\ is\ stale.}
\DoxyCodeLine{\ \ \ *\ -\/\ hit:\ the\ item\ is\ in\ the\ cache}
\DoxyCodeLine{\ \ \ *\ -\/\ miss:\ the\ item\ is\ not\ in\ the\ cache}
\DoxyCodeLine{\ \ \ */}
\DoxyCodeLine{\ \ get?:\ 'stale'\ |\ 'hit'\ |\ 'miss'}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ /**}
\DoxyCodeLine{\ \ \ *\ A\ fetch\ or\ get\ operation\ returned\ a\ stale\ value.}
\DoxyCodeLine{\ \ \ */}
\DoxyCodeLine{\ \ returnedStale?:\ true}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3747}{}\doxysubsection{\texorpdfstring{Storage Bounds Safety}{Storage Bounds Safety}}\label{README.md_autotoc_md3747}
This implementation aims to be as flexible as possible, within the limits of safe memory consumption and optimal performance.

At initial object creation, storage is allocated for {\ttfamily max} items. If {\ttfamily max} is set to zero, then some performance is lost, and item count is unbounded. Either {\ttfamily max\+Size} or {\ttfamily ttl} {\itshape must} be set if {\ttfamily max} is not specified.

If {\ttfamily max\+Size} is set, then this creates a safe limit on the maximum storage consumed, but without the performance benefits of pre-\/allocation. When {\ttfamily max\+Size} is set, every item {\itshape must} provide a size, either via the {\ttfamily size\+Calculation} method provided to the constructor, or via a {\ttfamily size} or {\ttfamily size\+Calculation} option provided to {\ttfamily cache.\+set()}. The size of every item {\itshape must} be a positive integer.

If neither {\ttfamily max} nor {\ttfamily max\+Size} are set, then {\ttfamily ttl} tracking must be enabled. Note that, even when tracking item {\ttfamily ttl}, items are {\itshape not} preemptively deleted when they become stale, unless {\ttfamily ttl\+Autopurge} is enabled. Instead, they are only purged the next time the key is requested. Thus, if {\ttfamily ttl\+Autopurge}, {\ttfamily max}, and {\ttfamily max\+Size} are all not set, then the cache will potentially grow unbounded.

In this case, a warning is printed to standard error. Future versions may require the use of {\ttfamily ttl\+Autopurge} if {\ttfamily max} and {\ttfamily max\+Size} are not specified.

If you truly wish to use a cache that is bound {\itshape only} by TTL expiration, consider using a {\ttfamily Map} object, and calling {\ttfamily set\+Timeout} to delete entries when they expire. It will perform much better than an LRU cache.

Here is an implementation you may use, under the same \href{./LICENSE}{\texttt{ license}} as this package\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ a\ storage-\/unbounded\ ttl\ cache\ that\ is\ not\ an\ lru-\/cache}
\DoxyCodeLine{const\ cache\ =\ \{}
\DoxyCodeLine{\ \ data:\ new\ Map(),}
\DoxyCodeLine{\ \ timers:\ new\ Map(),}
\DoxyCodeLine{\ \ set:\ (k,\ v,\ ttl)\ =>\ \{}
\DoxyCodeLine{\ \ \ \ if\ (cache.timers.has(k))\ \{}
\DoxyCodeLine{\ \ \ \ \ \ clearTimeout(cache.timers.get(k))}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ cache.timers.set(}
\DoxyCodeLine{\ \ \ \ \ \ k,}
\DoxyCodeLine{\ \ \ \ \ \ setTimeout(()\ =>\ cache.delete(k),\ ttl)}
\DoxyCodeLine{\ \ \ \ )}
\DoxyCodeLine{\ \ \ \ cache.data.set(k,\ v)}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\ \ get:\ k\ =>\ cache.data.get(k),}
\DoxyCodeLine{\ \ has:\ k\ =>\ cache.data.has(k),}
\DoxyCodeLine{\ \ delete:\ k\ =>\ \{}
\DoxyCodeLine{\ \ \ \ if\ (cache.timers.has(k))\ \{}
\DoxyCodeLine{\ \ \ \ \ \ clearTimeout(cache.timers.get(k))}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ cache.timers.delete(k)}
\DoxyCodeLine{\ \ \ \ return\ cache.data.delete(k)}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\ \ clear:\ ()\ =>\ \{}
\DoxyCodeLine{\ \ \ \ cache.data.clear()}
\DoxyCodeLine{\ \ \ \ for\ (const\ v\ of\ cache.timers.values())\ \{}
\DoxyCodeLine{\ \ \ \ \ \ clearTimeout(v)}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ cache.timers.clear()}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\}}

\end{DoxyCode}


If that isn\textquotesingle{}t to your liking, check out \href{http://npm.im/@isaacs/ttlcache}{\texttt{ @isaacs/ttlcache}}.\hypertarget{README.md_autotoc_md3748}{}\doxysubsection{\texorpdfstring{Storing Undefined Values}{Storing Undefined Values}}\label{README.md_autotoc_md3748}
This cache never stores undefined values, as {\ttfamily undefined} is used internally in a few places to indicate that a key is not in the cache.

You may call {\ttfamily cache.\+set(key, undefined)}, but this is just an an alias for {\ttfamily cache.\+delete(key)}. Note that this has the effect that {\ttfamily cache.\+has(key)} will return {\itshape false} after setting it to undefined.


\begin{DoxyCode}{0}
\DoxyCodeLine{cache.set(myKey,\ undefined)}
\DoxyCodeLine{cache.has(myKey)\ //\ false!}

\end{DoxyCode}


If you need to track {\ttfamily undefined} values, and still note that the key is in the cache, an easy workaround is to use a sigil object of your own.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ LRUCache\ \}\ from\ 'lru-\/cache'}
\DoxyCodeLine{const\ undefinedValue\ =\ Symbol('undefined')}
\DoxyCodeLine{const\ cache\ =\ new\ LRUCache(...)}
\DoxyCodeLine{const\ mySet\ =\ (key,\ value)\ =>}
\DoxyCodeLine{\ \ cache.set(key,\ value\ ===\ undefined\ ?\ undefinedValue\ :\ value)}
\DoxyCodeLine{const\ myGet\ =\ (key,\ value)\ =>\ \{}
\DoxyCodeLine{\ \ const\ v\ =\ cache.get(key)}
\DoxyCodeLine{\ \ return\ v\ ===\ undefinedValue\ ?\ undefined\ :\ v}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md3749}{}\doxysubsection{\texorpdfstring{Performance}{Performance}}\label{README.md_autotoc_md3749}
As of January 2022, version 7 of this library is one of the most performant LRU cache implementations in Java\+Script.

Benchmarks can be extremely difficult to get right. In particular, the performance of set/get/delete operations on objects will vary {\itshape wildly} depending on the type of key used. V8 is highly optimized for objects with keys that are short strings, especially integer numeric strings. Thus any benchmark which tests {\itshape solely} using numbers as keys will tend to find that an object-\/based approach performs the best.

Note that coercing {\itshape anything} to strings to use as object keys is unsafe, unless you can be 100\% certain that no other type of value will be used. For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ myCache\ =\ \{\}}
\DoxyCodeLine{const\ set\ =\ (k,\ v)\ =>\ (myCache[k]\ =\ v)}
\DoxyCodeLine{const\ get\ =\ k\ =>\ myCache[k]}
\DoxyCodeLine{}
\DoxyCodeLine{set(\{\},\ 'please\ hang\ onto\ this\ for\ me')}
\DoxyCodeLine{set('[object\ Object]',\ 'oopsie')}

\end{DoxyCode}


Also beware of "{}\+Just So"{} stories regarding performance. Garbage collection of large (especially\+: deep) object graphs can be incredibly costly, with several "{}tipping points"{} where it increases exponentially. As a result, putting that off until later can make it much worse, and less predictable. If a library performs well, but only in a scenario where the object graph is kept shallow, then that won\textquotesingle{}t help you if you are using large objects as keys.

In general, when attempting to use a library to improve performance (such as a cache like this one), it\textquotesingle{}s best to choose an option that will perform well in the sorts of scenarios where you\textquotesingle{}ll actually use it.

This library is optimized for repeated gets and minimizing eviction time, since that is the expected need of a LRU. Set operations are somewhat slower on average than a few other options, in part because of that optimization. It is assumed that you\textquotesingle{}ll be caching some costly operation, ideally as rarely as possible, so optimizing set over get would be unwise.

If performance matters to you\+:


\begin{DoxyEnumerate}
\item If it\textquotesingle{}s at all possible to use small integer values as keys, and you can guarantee that no other types of values will be used as keys, then do that, and use a cache such as \href{https://npmjs.com/package/lru-fast}{\texttt{ lru-\/fast}}, or \href{https://yomguithereal.github.io/mnemonist/lru-cache}{\texttt{ mnemonist\textquotesingle{}s LRUCache}} which uses an Object as its data store.
\item Failing that, if at all possible, use short non-\/numeric strings (ie, less than 256 characters) as your keys, and use \href{https://yomguithereal.github.io/mnemonist/lru-cache}{\texttt{ mnemonist\textquotesingle{}s LRUCache}}.
\item If the types of your keys will be anything else, especially long strings, strings that look like floats, objects, or some mix of types, or if you aren\textquotesingle{}t sure, then this library will work well for you.

If you do not need the features that this library provides (like asynchronous fetching, a variety of TTL staleness options, and so on), then \href{https://yomguithereal.github.io/mnemonist/lru-map}{\texttt{ mnemonist\textquotesingle{}s LRUMap}} is a very good option, and just slightly faster than this module (since it does considerably less).
\item Do not use a {\ttfamily dispose} function, size tracking, or especially ttl behavior, unless absolutely needed. These features are convenient, and necessary in some use cases, and every attempt has been made to make the performance impact minimal, but it isn\textquotesingle{}t nothing.
\end{DoxyEnumerate}\hypertarget{README.md_autotoc_md3750}{}\doxysubsection{\texorpdfstring{Breaking Changes in Version 7}{Breaking Changes in Version 7}}\label{README.md_autotoc_md3750}
This library changed to a different algorithm and internal data structure in version 7, yielding significantly better performance, albeit with some subtle changes as a result.

If you were relying on the internals of LRUCache in version 6 or before, it probably will not work in version 7 and above.\hypertarget{README.md_autotoc_md3751}{}\doxysubsection{\texorpdfstring{Breaking Changes in Version 8}{Breaking Changes in Version 8}}\label{README.md_autotoc_md3751}

\begin{DoxyItemize}
\item The {\ttfamily fetch\+Context} option was renamed to {\ttfamily context}, and may no longer be set on the cache instance itself.
\item Rewritten in Type\+Script, so pretty much all the types moved around a lot.
\item The Abort\+Controller/\+Abort\+Signal polyfill was removed. For this reason, {\bfseries{Node version 16.\+14.\+0 or higher is now required}}.
\item Internal properties were moved to actual private class properties.
\item Keys and values must not be {\ttfamily null} or {\ttfamily undefined}.
\item Minified export available at `\textquotesingle{}lru-\/cache/min'\`{}, for both CJS and MJS builds.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md3752}{}\doxysubsection{\texorpdfstring{Changes in Version 9}{Changes in Version 9}}\label{README.md_autotoc_md3752}

\begin{DoxyItemize}
\item Named export only, no default export.
\item Abort\+Controller polyfill returned, albeit with a warning when used.
\end{DoxyItemize}

For more info, see the change log. 